#!/usr/bin/env tl

parserParser = parser {

       sp: " " | "\t"
       nl: "\r\n" | "\n\r" | "\n" | "\r"
slcomment: "//" (!nl _)*
 icomment: "/*" (!"*/" _)* ("*/"|end)
  comment: (slcomment (nl|end) | icomment)
       ws: (sp | nl | comment)*

    name: ls=alpha+   -> ls.toChar

  escape: "\\\""      -> "\""
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"\"" l=_   -> l.toChar
    text: "\"" ts=escape* @"a closing '\"'" "\"" -> ts.join

  cscape: "\\]"       -> "]"
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"]" l=_    -> l.toChar
    char: "[" ts=cscape* @"closing ']'" "]" -> ts.join

     act: "->". ts=(!"\n" _)*             -> ts.toChar

    term: "(". t=or @"a closing ')'" .")" -> { type: "sub", term: t }
        | ".."                            -> { type: "call", target: "wsnl" }
        | "."                             -> { type: "call", target: "ws" }
        | "_"                             -> { type: "prim", target: "any" }
        | t=text                          -> { type: "prim", target: "text", text: t }
        | t=char                          -> { type: "prim", target: "char", text: t }
        | n=name !":" !"*:"               -> { type: "call", target: n }
    post: "!" @"a term" t=term            -> { type: "not", term: t }
        | "&" @"a term" t=term            -> { type: "ahead", term: t }
        | t=term "*(". @"a closing ')'" s=or .")" -> { type: "starsep", term: t, sep: s }
        | t=term "+(". @"a closing ')'" s=or .")" -> { type: "plussep", term: t, sep: s }
        | t=term "*"                      -> { type: "star", term: t, sep: null }
        | t=term "+"                      -> { type: "plus", term: t, sep: null }
        | t=term "?"                      -> { type: "opt", term: t }
        | term
   named: n=name "=" @"a term"  t=post    -> { type: "name", name: n, term: t }
        | "@" t=text                      -> { type: "anchor", msg: t }
        | post

     and: h=named rs=(.named)* .a=act?    -> { type: "and", terms: [h].cat(rs) }
      or: @"some terms"
          h=and rs=(."|". and)*           -> { type: "or", terms: [h].cat(rs) }

    spec: "*"                             -> "color"
        | ""

    rule: .n=name s=spec @":" ":". t=or  -> { type: "rule", name: n, term: t, spec: s }
  parser: n=name ."="."parser"."{"
          rs=rule*
          @"a closing '}'" ."}"           -> { n: n, rs: rs }
   start: b=(!(name ."="."parser"."{") _)*
          p=parser
          a=_*                            -> { before: b.toChar, after: a.toChar, rules: p.rs, name: p.n }
}

rules = HashMap.new
subs = Array.new
colors = Array.new

to_arg = t, name ->
    assert name
    { t.type == "sub"  }: to_sub(t.term, name)
    { t.type == "and"  }: to_sub(t, name)
    { t.type == "or"   }: to_sub(t, name)
    { t.type == "prim" }: to_sub({ type: "and", terms: [t] }, name)
    { t.type == "call" }: to_sub({ type: "and", terms: [t] }, name)
    { }: throw "ERROR to arg:"+ inspect(t)

to_call = t, name ->
    assert name
    { t.type == "and" }:
        if t.terms.size == 1 and not t.terms[1].type == "name": return to_call(t.terms[1], name)
        { type: "call", target: to_sub(t, name) }
    { t.type == "sub"     }:
        if t.term.terms.size == 1:
            return to_call(t.term.terms[1], name)
        { type: "call", target: to_sub(t.term, name) }
    { t.type == "name"    }: { type: "name", name: t.name, term: to_call(t.term, name) }
    { t.type == "call"    }:
        if not rules[t.target]: throw "rule without a definition: '$(t.target)'"
        { type: "call", target: "r_$(t.target)" }
    { t.type == "starsep" }: { type: "meta", target: "star", args: [to_arg(t.term, name), to_arg(t.sep, name)] }
    { t.type == "plussep" }: { type: "meta", target: "plus", args: [to_arg(t.term, name), to_arg(t.sep, name)] }
    { t.type == "star"    }: { type: "meta", target: "star", args: [to_arg(t.term, name),"null"] }
    { t.type == "plus"    }: { type: "meta", target: "plus", args: [to_arg(t.term, name),"null"] }
    { t.type == "opt"     }: { type: "meta", target: "opt", args: [to_arg(t.term, name)] }
    { t.type == "not"     }: { type: "meta", target: "not", args: [to_arg(t.term, name)] }
    { t.type == "ahead"   }: { type: "meta", target: "ahead", args: [to_arg(t.term, name)] }

    { t.type == "prim"    }: t
    { t.type == "anchor"  }: t
    { }: throw "ERROR to call:"+ inspect(t)

to_sub = t, name, rule, number ->
    number = number or 0
    name = { rule }: "r_$(rule)"
           {      }: "$(name)_$(subs.size)"
    { t.type == "and" }:
        terms = t.terms.map(t -> to_call(t, name))
        subs.add { type: "and", { name, number, terms }}
        return name
    { t.type == "or" }:
        if t.terms.size == 1: return to_sub(t.terms[1], name, rule, number)
        terms = t.terms.map(t -> to_call(t, name))
        subs.add { type: "or", { name, number, terms }}
        return name
    { }: throw "ERROR to sub:"+ inspect(t)

ast = parserParser(io.File(args[1]).readString)
ast.rules.each: rule ->
    if rules[rule.name]: throw "rule already defined '$(rule.name)'"
    rules[rule.name] = true
if not rules["ws"]:
    rules["ws"] = true
    to_sub({ type: "and", terms: [{ type: "prim", target: "ws" }] }, null, "ws")
if not rules["wsnl"]:
    rules["wsnl"] = true
    to_sub({ type: "and", terms: [{ type: "prim", target: "wsnl" }] }, null, "wsnl")
ast.rules.each: rule ->
    number = { rule.spec == "color" }: colors.add rule.name; colors.size
             {                      }: 0
    assert number
    to_sub(rule.term, null, rule.name, number)
if not rules["start"] and ast.rules.size > 0:
    to_sub({ type: "and", terms: [{ type: "call", target: ast.rules.last.name }] }, null, "r_start")

emit = term ->
    { term.type == "call" }: "$(term.target)(p, pos);"
    { term.type == "meta" }: "meta_$(term.target)(p, pos$(term.args.map(a -> ", $a").join));"
    { term.type == "prim" and term.text }: "prim_$(term.target)(p, pos, \"$(term.text.escape)\");"
    { term.type == "prim" }: "prim_$(term.target)(p, pos);"
    { term.type == "name" }: emit(term.term)
    { }: throw "ERROR emit:"+ inspect(term)

lines = Array.new
lines.add "#include \"tlmeta.c\""
lines.add ""
lines.add "const char* const colors[] = {\"\","+ colors.toList.map(c->"\"$(c.escape)\"").join(",") +",null};"
emit_declare = rule -> lines.add "static State $(rule.name)(Parser*, int);"
subs.each(r -> emit_declare(r))
lines.add ""

emit_rule = rule ->
    lines.add "static State $(rule.name)(Parser* p, int start) { // $(rule.type)"
    lines.add " parser_enter(p, \"$(rule.name)\", start);"
    lines.add " int pos = start;"
    { rule.terms.size == 1 and not rule.terms[1].type == "name" }:
        print "HU:", rule.name, rule.number
        assert rule.number
        lines.add " State r = "+ emit(rule.terms[1])
        lines.add " if (r.ok) return parser_pass(p, \"$(rule.name)\", $(rule.number), start, r.pos, r.value);"
        lines.add " if (p->error_line) { print(\"expect: $(rule.name)\"); return r; }"
        lines.add " return parser_fail(p, \"$(rule.name)\", start);"
    { rule.type == "or" }:
        lines.add " State r;"
        rule.terms.each: term ->
            lines.add " r = "+ emit(term)
            lines.add " if (r.ok) return parser_pass(p, \"$(rule.name)\", $(rule.number), start, r.pos, r.value);"
            lines.add " if (p->error_line) { print(\"expect: $(rule.name)\"); return r; }"
        lines.add " return parser_fail(p, \"$(rule.name)\", start);"
    { rule.type == "and" }:
        anchor = Var.new
        names = Array.new
        lines.add " State r;"
        rule.terms.each: term ->
            if term.type == "anchor":
                if not $anchor: lines.add " const char* anchor = p->anchor;"
                lines.add " p->anchor = \"$(term.msg.escape)\";"
                $anchor = true
                return
            lines.add " r = "+ emit(term)
            if not $anchor:
                lines.add " if (!r.ok) return parser_fail(p, \"$(rule.name)\", pos);"
            if $anchor:
                lines.add " if (!r.ok) return parser_error(p, \"$(rule.name)\", start, pos);"
            lines.add " pos = r.pos;"
            if term.type == "name":
                names.add term.name
                lines.add " tlHandle _$(term.name) = r.value;"
        if names.size > 0:
            inner = names.toList.map(n -> "\"$n\", _$n").join(", ")
            lines.add " tlHandle v = tlObjectFrom($inner, null);"
        if names.size == 0:
            lines.add " tlHandle v = r.value;"
        if $anchor: lines.add " p->anchor = anchor;"
        lines.add " return parser_pass(p, \"$(rule.name)\", $(rule.number), start, pos, v);"
    lines.add "}"
subs.each(r -> emit_rule(r))

io.File(args[2]).write(lines.join("\n"))

