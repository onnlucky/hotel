#!/usr/bin/env tl

/*
  TODO
remove the weird rule indend thing which leads to body_222_222_222
add parser known "braces" open/close to expect the matching brace
*/

no_value = false

parserParser = parser {

       sp: " " | "\t"
       nl: "\r\n" | "\n\r" | "\n" | "\r"
slcomment: "//" (!nl _)*
 icomment: "/*" (!"*/" _)* ("*/"|end)
  comment: (slcomment (nl|end) | icomment)
       ws: (sp | nl | comment)*

    name: ls=(alpha|numeric|[_])+   -> ls.toChar

  escape: "\\\""      -> "\""
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"\"" l=_   -> l.toChar
    text: "\"" ts=escape* @"a closing '\"'" "\"" -> ts.join

  cscape: "\\]"       -> "]"
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"]" l=_    -> l.toChar
    char: "[" ts=cscape* @"closing ']'" "]" -> ts.join

     act: "->". ts=(!"\n" _)*             -> ts.toChar

    term: "(". t=or @"a closing ')'" .")" -> { type: "sub", term: t }
        | ".."                            -> { type: "call", target: "wsnl" }
        | "."                             -> { type: "call", target: "ws" }
        | "_"                             -> { type: "prim", target: "any" }
        | t=text                          -> { type: "prim", target: "text", text: t }
        | t=char                          -> { type: "prim", target: "char", text: t }
        | "pos" !alpha !"_" !":" !"*:"    -> { type: "prim", target: "pos" }
        | "setindent" !alpha !"_" !":" !"*:" -> { type: "setindent" }
        | "indent" !alpha !"_" !":" !"*:" -> { type: "indent" }
        | n=name !"_" !":" !"*:"          -> { type: "call", target: n }
    post: "!" @"a term" t=term            -> { type: "not", term: t }
        | "&" @"a term" t=term            -> { type: "ahead", term: t }
        | t=term "*(". @"a closing ')'" s=or .")" -> { type: "starsep", term: t, sep: s }
        | t=term "+(". @"a closing ')'" s=or .")" -> { type: "plussep", term: t, sep: s }
        | t=term "*"                      -> { type: "star", term: t, sep: null }
        | t=term "+"                      -> { type: "plus", term: t, sep: null }
        | t=term "?"                      -> { type: "opt", term: t }
        | term
   named: n=name "=<" t=name ">"          -> { type: "name", name: n, term: { type: "token", token: t }}
        | n=name "=" @"a term"  t=post    -> { type: "name", name: n, term: t }
        | "@" t=text                      -> { type: "anchor", msg: t }
        | "@"                             -> { type: "anchor", msg: "" }
        | post

     and: h=named rs=(.named)* .a=act?    -> { type: "and", terms: [h].cat(rs), act: a }
      or: @"some terms"
          h=and rs=(."|". and)*           -> { type: "or", terms: [h].cat(rs) }

    spec: "*"                             -> "color"
        | ""

    rule: .n=name s=spec @":" ":". t=or  -> { type: "rule", name: n, term: t, spec: s }
  parser: n=name ."="."parser"."{"
          rs=rule*
          @"a closing '}'" ."}"           -> { n: n, rs: rs }
   start: b=(!(name ."="."parser"."{") _)*
          p=parser
          a=_*                            -> { before: b.toChar, after: a.toChar, rules: p.rs, name: p.n }
}

rules = HashMap.new
jumps = Array.new

Branches = char, call, done -> {
    char: char
    call: call
    done: done
    table: Array.new
    jump: Var.new
    follow: rule, char, call, done ->
        this.table.each: branch =>
            if branch.jump.get: print "warning: a jump found while following '$(rule)'"
            if branch.done: print "warning: '$(branch.done)' shadows '$(rule)'"
            if char and branch.char == char: return branch
        this.table.add Branches(char, call, done)
    followString: rule, string ->
        branch = Var.new this
        string.each: char -> $branch = $branch.follow(rule, char)
        return $branch
    followCall: rule, name ->
        this.follow(rule, null, name)
    followDone: rule ->
        this.follow(rule, null, null, rule)
    setjump: rule, to ->
        if this.jump.get: print "warning: a jump overrides previous jump while following '$(rule)'"
        this.jump.set to
    print: indent ->
        indent = indent or ""
        jump = bool(this.jump.get, " -> $(this.jump.get)", "")
        if this.call: print "$(indent)call:$(this.call)$jump"
        if this.done: print "$(indent)done:$(this.done)$jump"
        if this.char: print "$(indent)$(this.char.toChar)$jump"
        this.table.each(branch -> branch.print "$indent  ")
}

seen = HashMap.new
rights = HashMap.new

strace = rule, term, branch, lefts, left_mode ->
    { term.type == "and" }:
        branch = Var.new branch
        term.terms.each: t, n =>
            $branch = strace rule, t, $branch, bool(n == 1, lefts, [:]), bool(n == 1, left_mode, null)
            if not $branch: return null
        return $branch.followDone(rule)
    { term.type == "or" }:
        term.terms.map(t -> strace rule, t, branch, lefts, left_mode)
    { term.type == "call" }:
        name = term.target
        if left_mode == name: return branch
        if left_mode: return null
        if lefts[name]: return null
        lasts = strace_rule(name, branch, lefts)
        _, at = lasts.find(l -> l == null) // look for nulls, left recursion leaves them, create right version and call it
        if at:
            rights[name] = true
            lasts = lasts.filter(l -> l)
            if lasts.size == 1:
                return lasts[1].followCall(rule, "right-$(name)")
            jump, j = jumps.add Branches('*')
            print "create jump for left version: $j $(name)"
            lasts.each: l -> l.setjump(rule, j)
            return jump.followCall(rule, "right-$(name)")
        if lasts.size == 1: return lasts[1]
        jump, j = jumps.add Branches('*')
        print "create jump for: $j $(name)"
        lasts.each: l -> if l: l.setjump(rule, j)
        return jump
    { term.type == "sub"  }:
        lasts = strace rule, term.term, branch, lefts, left_mode
        if lasts.size == 1: return lasts[1]
        jump, j = jumps.add Branches('*')
        lasts.each: l -> if l: l.setjump(rule, j)
        return jump
    { left_mode }: null
    { term.type == "prim" and term.target == "text" }: branch.followString(rule, term.text)
    { }: print repr term

strace_right = name ->
    rule = rules[name]
    branch, j = jumps.add Branches('*')
    print "create jump right version: $j $(name)"
    right_lasts = strace name, rule.term, branch, [:], name
    right_lasts.each: l -> if l: l.followCall(name, "right-$(name)")
    branch.followDone(name)

strace_rule = name, branch, lefts, left_mode ->
    rule = rules[name]
    if not rule: throw "rule undefined '$(name)'"
    if seen[name]:
        print "$name is recursive"
        return [branch.followCall(name, name)]
    print "tracing", name
    seen[name] = true
    lasts = strace name, rule.term, branch, lefts.set(name, true), left_mode
    seen[name] = false
    return lasts

ast = parserParser(io.File(args[1]).readString)
ast.rules.each: rule ->
    if rules[rule.name]: throw "rule already defined '$(rule.name)'"
    rules[rule.name] = rule

// add some default rules if they don't exist
if not rules["ws"]:
    rules["ws"] = { name: "ws", term: { type: "and", terms: [{ type: "prim", target: "ws" }]}, spec: null}
if not rules["wsnl"]:
    rules["wsnl"] = { name: "wsnl", term: { type: "and", terms: [{ type: "prim", target: "wsnl" }]}, spec: null}
if not rules["start"] and ast.rules.size > 0:
    rules["start"] = { name: "start", term: { type: "and", terms: [{ type: "call", target: ast.rules.last.name }]}, spec: null}

start = jumps.add(Branches('*'))
branch = strace_rule("start", start, [:])
rights.each: k -> strace_right(k)
jumps.each: jump, n -> print "JUMP: $n"; jump.print

