#!/usr/bin/env tl

/*
  TODO
remove the weird rule indend thing which leads to body_222_222_222
add parser known "braces" open/close to expect the matching brace
*/

no_value = false

parserParser = parser {

       sp: " " | "\t"
       nl: "\r\n" | "\n\r" | "\n" | "\r"
slcomment: "//" (!nl _)*
 icomment: "/*" (!"*/" _)* ("*/"|end)
  comment: (slcomment (nl|end) | icomment)
       ws: (sp | nl | comment)*

    name: ls=(alpha|numeric|[_])+   -> ls.toChar

  escape: "\\\""      -> "\""
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"\"" l=_   -> l.toChar
    text: "\"" ts=escape* @"a closing '\"'" "\"" -> ts.join

  cscape: "\\]"       -> "]"
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"]" l=_    -> l.toChar
    char: "[" ts=cscape* @"closing ']'" "]" -> ts.join

     act: "->". ts=(!"\n" _)*             -> ts.toChar

    term: "(". t=or @"a closing ')'" .")" -> { type: "sub", term: t }
        | ".."                            -> { type: "call", target: "wsnl" }
        | "."                             -> { type: "call", target: "ws" }
        | "_"                             -> { type: "prim", target: "any" }
        | t=text                          -> { type: "prim", target: "text", text: t }
        | t=char                          -> { type: "prim", target: "char", text: t }
        | "pos" !alpha !"_" !":" !"*:"    -> { type: "prim", target: "pos" }
        | "setindent" !alpha !"_" !":" !"*:" -> { type: "setindent" }
        | "indent" !alpha !"_" !":" !"*:" -> { type: "indent" }
        | n=name !"_" !":" !"*:"          -> { type: "call", target: n }
    post: "!" @"a term" t=term            -> { type: "not", term: t }
        | "&" @"a term" t=term            -> { type: "ahead", term: t }
        | t=term "*(". @"a closing ')'" s=or .")" -> { type: "starsep", term: t, sep: s }
        | t=term "+(". @"a closing ')'" s=or .")" -> { type: "plussep", term: t, sep: s }
        | t=term "*"                      -> { type: "star", term: t, sep: null }
        | t=term "+"                      -> { type: "plus", term: t, sep: null }
        | t=term "?"                      -> { type: "opt", term: t }
        | term
   named: n=name "=<" t=name ">"          -> { type: "name", name: n, term: { type: "token", token: t }}
        | n=name "=" @"a term"  t=post    -> { type: "name", name: n, term: t }
        | "@" t=text                      -> { type: "anchor", msg: t }
        | "@"                             -> { type: "anchor", msg: "" }
        | post

     and: h=named rs=(.named)* .a=act?    -> { type: "and", terms: [h].cat(rs), act: a }
      or: @"some terms"
          h=and rs=(."|". and)*           -> { type: "or", terms: [h].cat(rs) }

    spec: "*"                             -> "color"
        | ""

    rule: .n=name s=spec @":" ":". t=or  -> { type: "rule", name: n, term: t, spec: s }
  parser: n=name ."="."parser"."{"
          rs=rule*
          @"a closing '}'" ."}"           -> { n: n, rs: rs }
   start: b=(!(name ."="."parser"."{") _)*
          p=parser
          a=_*                            -> { before: b.toChar, after: a.toChar, rules: p.rs, name: p.n }
}

rules = HashMap.new
jumps = Array.new

Branches = char, call -> {
    char: char
    call: call
    table: Array.new
    jump: Var.new
    follow: char ->
        this.table.each: branch =>
            if branch.char == char: return branch
        this.table.add Branches(char)
    followString: string ->
        branch = Var.new this
        string.each: char -> $branch = $branch.follow(char)
        return $branch
    followCall: name ->
        this.table.add Branches('*', name)
    setjump: to ->
        this.jump.set to
    factor: ->
        if this.table.size == 0: return 1
        this.table.map(branch -> branch.factor).sum
    print: indent ->
        indent = indent or ""
        if this.jump.get:
            print "$(indent)$(this.char.toChar) -> $(this.jump.get)"
            return
        print "$(indent)$(this.char.toChar)$(this.call or "")"
        this.table.each(branch -> branch.print "$indent  ")
}

seen = HashMap.new

strace = term, branch, lefts ->
    { term.type == "and" }:
        branch = Var.new branch
        term.terms.each: t, n =>
            $branch = strace t, $branch, bool(n == 1, lefts, [:])
            if not $branch: return null
        return $branch.follow('.')
    { term.type == "or" }:
        term.terms.map(t -> strace t, branch, lefts)
    { term.type == "sub"  }:
        lasts = strace term.term, branch, lefts
        if lasts.size == 1: return lasts[1]
        jump, j = jumps.add Branches('*')
        lasts.each: l -> if l: l.setjump(j)
        return jump
    { term.type == "call" }:
        if lefts[term.target]: return null
        lasts = strace_rule(term.target, branch, lefts)
        if lasts.size == 1: return lasts[1]
        _, at = lasts.find(l -> l == null)
        if at:
            // left recursion leaves nulls ... call the right recursion version
            jump, j = jumps.add Branches('*')
            lasts.each: l -> if l: l.setjump(j)
            return jump.followCall("right-$(term.target)")
        jump, j = jumps.add Branches('*')
        lasts.each: l -> if l: l.setjump(j)
        return jump
    { term.type == "prim" and term.target == "text" }: branch.followString(term.text)
    { }: print repr term

strace_rule = name, branch, lefts ->
    rule = rules[name]
    if not rule: throw "rule undefined '$(name)'"
    if seen[name]:
        return [branch.followCall(name)]
    print "tracing", name
    seen[name] = true
    lasts = strace rule.term, branch, lefts.set(name, true)
    seen[name] = false
    return lasts

ast = parserParser(io.File(args[1]).readString)
ast.rules.each: rule ->
    if rules[rule.name]: throw "rule already defined '$(rule.name)'"
    rules[rule.name] = rule

// add some default rules if they don't exist
if not rules["ws"]:
    rules["ws"] = { name: "ws", term: { type: "and", terms: [{ type: "prim", target: "ws" }]}, spec: null}
if not rules["wsnl"]:
    rules["wsnl"] = { name: "wsnl", term: { type: "and", terms: [{ type: "prim", target: "wsnl" }]}, spec: null}
if not rules["start"] and ast.rules.size > 0:
    rules["start"] = { name: "start", term: { type: "and", terms: [{ type: "call", target: ast.rules.last.name }]}, spec: null}

start = jumps.add(Branches('*'))
branch = strace_rule("start", start, [:])
start = jumps.add(Branches('*'))
branch = strace_rule("call", start, [:])
jumps.each: jump, n -> print "JUMP: $n"; jump.print

