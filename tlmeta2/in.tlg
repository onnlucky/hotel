parser = parser {
     end: !_
      sp: " " | "\t"
      nl: "\r\n" | "\n\r" | "\n" | "\r"

slcomment*: "#" (!nl _)* (nl|end)
  comment*: "(#" (!"#)" (comment|_))* ("#)"|end)

      ws: (sp | comment)*
    wsnl: (sp | nl | comment | slcomment)*

     eov: . ("," | nl | slcomment)
  eoexpr: . ("," | ";" | ":" | nl | end | ")" | "}" | "]" | slcomment)
   eostm: . (";" | nl | end | ")" | "}" | "]" | slcomment)
 endexpr: @"end of expression" . ("," | ";" | ":" | nl | end | ")" | "}" | "]" | slcomment)
  endstm: @"end of expression" . (";" | nl | end | ")" | "}" | "]" | slcomment)

  letter: [@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789]
   first: [@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
    name: f=first fs=letter* -> String(prepend(fs,f))

// ---- TEXT ----

  escape: "\\\""      -> tlINT('"')
        | "\\n"       -> tlINT('\n')
        | "\\r"       -> tlINT('\r')
        | "\\t"       -> tlINT('\t')
        | "\\\\"      -> tlINT('\\')
        | !"\"" _
   stext: ts=(!"%" escape)+                      -> String(ts)
   embed: "%%"
        | "%(".. body=body ..")" type=<scope>
        | "%" e=ref                              -> e
   text*: "\"\""                                 -> tlStringEmpty()
        | "\"" t=stext "\""                      -> t
        | "\"" @"a closing '\"'" data=(embed|stext)* "\"" type=<string>

// ---- NUMBERS ----

    sign: "-"                      -> tlINT(-1)
        | "+"                      -> tlINT(1)
        | ""                       -> tlINT(1)
    comp: n=([0123456789]+)+("_"+) !"_" -> flatten(n)
    num*: s=sign w=comp "." f=comp -> Float(s, w, f, 10)
        | s=sign        "." f=comp -> Float(s, null, f, 10)
        | s=sign w=comp            -> Number(s, w, 10)

// ---- OBJECT, MAP AND LIST ----

  object: "{".. data=items @"a closing '}'" .."}" type=<object>
        | "{"..@"a closing '}'" "}"               type=<object>
     map: "[".. data=mapitems @"a closing ']'" .."]" type=<map>
        | "[".."=" @"a closing ']'" .."]"         type=<map>
   items: i=item is=(eov.. item)*                             -> prepend(is, i)
mapitems: i=(n=key ."="..@"a value" v=mexpr) is=(eov.. item)* -> prepend(is, i)
    key*: name
    item: n=key .@"a '='" "="..@"a value" v=mexpr

    list: "[".. data=litems @"a closing ']'" .."]" type=<list>
        | "["..@"a closing ']'" "]"                type=<list>
  litems: i=mexpr !"=" is=(eov.. mexpr)*          -> prepend(is, i)

// ---- FUNCTION DEFINITION ----

    class: pos=pos "{".. as=fargs .."->"..@"a closing '}'" body=body .."}" type=<function>
 function: pos=pos "(".. as=fargs .."->"..@"a closing ')'" body=body ..")" type=<function>
         | pos=pos arg=farg ."->".. body=bodynl                            type=<function>
         | pos=pos "->".. body=bodynl                                      type=<function>
         | block
mfunction: pos=pos args=fargs ."->".. body=bodynl                          type=<function>
    block: pos=pos ":".. args=fargs .."->".. body=bodynl                       type=<block>
         | pos=pos ":".."("..as=fargs .."->"..@"a closing ')'" body=body ..")" type=<block>
         | pos=pos ":".. body=bodynl type=<block>

     type: "("."@". n=name ")" -> n
    deflt: "("."=". v=mexpr ")" -> v
    farg*: "&&" pos=pos name=intro type=<lazycollect>
         | "&" pos=pos name=intro t=type? d=deflt? type=<lazy>
         | "*" pos=pos name=intro type=<collect>
         |  pos=pos name=intro t=type? d=deflt? type=<eager>
    fargs: a=farg as=(..",".. farg)* -> prepend(as, a)
         | "" -> tlListEmpty()

// ---- EXPRESSIONS ----

literal*: "true" | "false" | "null" | "undefined"
  opname: ("not"|"and"|"or"|"xor") !letter
    ref*: pos=pos !opname name=name type=<ref>
 varref*: pos=pos "$" name=name type=<varref>
   value: function
        | class
        | object
        | map
        | list
        | "("..@"a closing ')'" body=body ..")" type=<scope>
        | num | text
        | literal
        | varref
        | ref

   margs: e=arg es=(..","..@"a value" arg)*                                  -> prepend(es, e)
    args: f=mfunction                                                        -> tlListFrom1(f)
        | e=arg es=(..","..@"a value" arg)*                                  -> prepend(es, e)
        | ""                                                                 -> tlListEmpty()
     arg: n=name ."="!"=".@"a value" v=expr
        | v=expr

     met: "."
        | "::"
        | m="?" &(.. first) -> m
        | m="!" &(.. first) -> m
 method*: name
    tail: pos=pos ."("..@"a closing ')'" args=args ..")" t=tail                   -> process_call(args, t, pos)
        | pos=pos .o=met.. m=method ."("..@"a closing ')'" args=args ..")" t=tail -> process_method(o, m, args, t, pos)
        | pos=pos .".".. m=method ."="!"=".. @"a value" value=mexpr               -> process_set_field(m, value, pos)
        | pos=pos .o=met..@"a method call" m=method t=tail                        -> process_method(o, m, tlListEmpty(), t, pos)
        | pos=pos ."[".. key=expr .."]" ."="!"=".. @"a value" value=mexpr         -> process_set(key, value, pos)
        | pos=pos ."[".. key=expr .."]" t=tail                                    -> process_get(key, t, pos)
        | pos=pos ."["..@"a closing ']'" from=expr?..":"..to=expr?.."]" t=tail    -> process_slice(from, to, t, pos)
        | ""                                                                      -> tlNull
    call: value=value t=tail                                                      -> process_tail(value, t)
  mmcall: pos=pos target=ref " ". arg=mmcall                                      -> process_mcall(target, arg, pos)
        | pos=pos target=ref " ". args=margs type=<call>
   mcall: pos=pos call=mmcall block=block?                                        -> process_add_block(call, block, pos)
        | pos=pos call=call block=block?                                          -> process_add_block(call, block, pos)

      op: "+" | "-" | "*" | "//" | "/" | "%" | "^"
    expr: "!". body=logical &endexpr type=<async>
        | e=logical &endexpr                                                     -> e

 logical: l=not rs=(..pos=pos op=("or"|"and"|"xor").. r=logical)?                -> process_expr(l, rs)
     not: pos=pos type="not".. r=not | compare
 compare: l=bitwise rs=(..pos=pos op=("<="|"<"|">="|">"|"=="|"!=").. r=compare)? -> process_expr(l, rs)
 bitwise: l=shift rs=(..pos=pos op=("&"|"|").. r=bitwise)?                       -> process_expr(l, rs)
   shift: l=add rs=(..pos=pos op=("<<"|">>").. r=shift)?                         -> process_expr(l, rs)
     add: l=mul rs=(..pos=pos op=("+"|"-").. r=add)?                             -> process_expr(l, rs)
     mul: l=pow rs=(..pos=pos op=("*"|"//"|"/"|"%").. r=mul)?                    -> process_expr(l, rs)
     pow: l=paren rs=(..pos=pos op=("^").. r=pow)?                               -> process_expr(l, rs)
   paren: &"(" function
        | "("..@"a closing ')'" body=body ..")" type=<scope>
        | call

// ---- STATEMENTS ----

  intro*: name
  tovar*: "$" name
  assign: tovar
        | intro
   mexpr: e=mfunction &endexpr                                               -> e
        | "!". body=stms type=<async>
        | e=mcall &eostm                                                     -> e
        | expr
     stm: pos=pos to=tovar .op=op "="!"=".. @"a value" value=mexpr &endstm type=<assignop>
        | pos=pos to=assign ."="!"=".. @"a value" value=mexpr &endstm type=<assign>
        | multi=(pos=pos to=assign)+(.","..) .."="!"=".. @"a value" stms=stms type=<multiassign>
        | e=mexpr &endstm                                                    -> e

   stms*: t=stm ts=(.";".@"a statement after ';'" stm)* -> prepend(ts, t)
   mstms: @"a statement" stms

// ---- BLOCKS ----

   body*: ts=stms tss=(.. stms)*                        -> flatten(prepend(tss, ts))
        | ""                                            -> tlListEmpty()

 bodynl*: setindent ts=stms tss=(.. indent !end mstms)* -> flatten(prepend(tss, ts))
        | ""                                            -> tlListEmpty()

hashbang: "#!" (!nl _)*
 mustend: @"indent error" .. end
   start: .. hashbang? .. pos=pos body=bodynl mustend type=<function>
}

