parser = parser {
     end: !_
      sp: " " | "\t"
      nl: "\r\n" | "\n\r" | "\n" | "\r"

slcomment*: "#" (!nl _)* (nl|end)
  comment*: "(#" (!"#)" (comment|_))* ("#)"|end)

      ws: (sp | comment)*
    wsnl: (sp | nl | comment | slcomment)*

     eos: . (";" | nl | slcomment)
     eov: . ("," | nl | slcomment)
  eoexpr: . ("," | ";" | nl | end | ")" | "}" | "]" | slcomment)
   eostm: . (";" | nl | end | ")" | "}" | "]" | slcomment)
 endexpr: @"end of expression" &eoexpr
  endstm: @"end of expression" &eostm

  letter: [@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789]
   first: [@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
    name: f=first fs=letter* -> String(prepend(fs,f))

// ---- TEXT ----

  escape: "\\\""      -> tlINT('"')
        | "\\n"       -> tlINT('\n')
        | "\\r"       -> tlINT('\r')
        | "\\t"       -> tlINT('\t')
        | "\\\\"      -> tlINT('\\')
        | !"\"" _
   stext: "\"" ts=escape* @"a closing '\"'" "\"" -> String(ts)
   text*: stext

// ---- NUMBERS ----

    sign: "-"                      -> tlINT(-1)
        | "+"                      -> tlINT(1)
        | ""                       -> tlINT(1)
    comp: n=([0123456789]+)+("_"+) !"_" -> flatten(n)
    num*: s=sign w=comp "." f=comp -> Float(s, w, f, 10)
        | s=sign        "." f=comp -> Float(s, null, f, 10)
        | s=sign w=comp            -> Number(s, w, 10)

// ---- OBJECT, MAP AND LIST ----

  object: "{".. is=items @"a closing '}'" .."}"
        | "{"..@"a closing '}'" "}"
     map: "[".. is=items @"a closing ']'" .."]"
        | "["..":" @"a closing ']'" .."]"
   items: i=item is=(eov.. items)*                -> prepend(is, i)
    key*: name
    item: n=key .@"a ':'" ":"..@"a value" v=mexpr

    list: "[".. is=litems @"a closing ']'" .."]"
        | "[".."]"
  litems: i=mexpr !":" is=(eov.. litems)*         -> prepend(is, i)

// ---- FUNCTION DEFINITION ----

    class: "{".. as=fargs .."->"..@"a closing '}'" b=body .."}"
 function: "(".. as=fargs .."->"..@"a closing ')'" b=body ..")"
         | a=farg .."->".. b=bodynl
         | "->".. b=bodynl
mfunction: as=fargs .."->".. b=bodynl

    farg*: name
    fargs: a=farg as=(..",".. farg)* -> prepend(as, a)
         | ""

// ---- EXPRESSIONS ----

literal*: "true" | "false" | "null" | "undefined"
    ref*: name
   value: function
        | class
        | object
        | list
        | map
        | num | text
        | literal
        | ref

    args: e=expr es=(..","..@"a value after ','" expr)* -> prepend(es, e)
        | ""

     met: "." | "::"
        | "?" &(.. first)
        | "!" &(.. first)
 method*: name
    tail: ."("..@"a closing ')'" args=args ..")" t=tail                      -> process_call(args, t)
        | .o=met.. m=method ."("..@"a closing ')'" args=args ..")" t=tail    -> process_method(o, m, args, t)
        | .o=met..@"a method call" m=method t=tail                           -> process_method(o, m, tlListEmpty(), t)
        | ""                                                                 -> tlNull
    call: value=value t=tail                                                 -> process_tail(value, t)

      op: "+" | "-" | "*" | "/" | "%" | "^"
    expr: e=logical endexpr                                                  -> e

 logical: l=not rs=(..op=("or"|"and"|"xor").. r=logical)?                    -> process_expr(l, rs)
     not: type="not".. r=not | compare
 compare: l=bitwise rs=(..op=("<="|"<"|">"|">="|"=="|"!=").. r=compare)?     -> process_expr(l, rs)
 bitwise: l=shift rs=(..op=("&"|"|").. r=bitwise)?                           -> process_expr(l, rs)
   shift: l=add rs=(..op=("<<"|">>").. r=shift)?                             -> process_expr(l, rs)
     add: l=mul rs=(..op=("+"|"-").. r=add)?                                 -> process_expr(l, rs)
     mul: l=pow rs=(..op=("*"|"/"|"//"|"%").. r=mul)?                        -> process_expr(l, rs)
     pow: l=paren rs=(..op=("^").. r=pow)?                                   -> process_expr(l, rs)
   paren: "("..@"a closing ')'" e=expr ..")"                                 -> e
        | call

// ---- STATEMENTS ----

  intro*: name
   mexpr: e=mfunction endexpr                                                -> e
        | expr
     stm: n=intro .":"!":".. @"a value" e=mexpr endstm
        | e=mexpr @"end of expression" endstm                                -> e

    stms: t=stm ts=(.";".@"statement after ';'" stm)* -> prepend(ts, t)
    // stms: stm+(.";".@"statement after ';'")

// ---- BLOCKS ----

    body: ts=stms tss=(eos.. stms)* -> flatten(prepend(tss, ts))
        | ""

  bodynl: ts=stms

hashbang: "#!" (!nl _)*
   start: .. hashbang? .. b=body .. end -> b
}

