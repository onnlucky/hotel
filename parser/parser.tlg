set_target = (call, fn ->
    if not call.target: return _Map_set(call, #target, fn)
    _Map_set(call, #target, set_target(call.target, fn))
)

parse = parser {
     end: !_
      sp: " " | "\t"
      nl: "\r\n" | "\n\r" | "\n" | "\r"
      ws: sp*
    wsnl: (sp | nl)*
   sepnl: ("," | nl) wsnl
   eostm: (";" | nl | end | !(!")") | !(!"}") !(!"]")) wsnl

nonident: " " | "\n" | "\r" | "\t" | "." | "!" | ";" | "," | "(" | ")" | "{" | "}" | "[" | "]"
   ident: n=alpha rs=(!nonident _)* -> rs.prepend(n).toChar

    sign: "-" -> -1
        | "+" ->  1
        | .   ->  1
     num: s=sign n=numr        -> s * n.reduce((l, r -> l * 10 + r))
    numr: n=numeric "_" b=numr -> b.prepend(n - 48)
        | n=numeric b=numr     -> b.prepend(n - 48)
        | n=numeric            -> [n - 48]

   value: "(".@"closing ')'" c=stm .")"     -> c
        | n=ident                           -> { type: #ref, name: n }
        | num

    args: a=expr as=(.sepnl expr)*          -> as.prepend(a)
        | .                                 -> []
    tail: "(". as=args .")" (
            t=tail                          -> set_target(t, { type: #call, target: null, args: [as] })
            | .                             -> { type: #call, target: null, args: [as] }
        )
        | "[". l=expr? .":". r=expr? ."]" (
            t=tail                          -> set_target(t, { type: #send, target: null, msg: #slice, args: [l, r] })
            | .                             -> { type: #send, target: null, msg: #slice, args: [l, r] }
        )
        | "[". e=expr ."]" (
            t=tail                          -> set_target(t, { type: #send, target: null, msg: #get, args: [e] })
            | .                             -> { type: #send, target: null, msg: #get, args: [e] }
        )
        | "." n=ident "(". as=args .")" (
            t=tail                          -> set_target(t, { type: #send, target: null, msg: n, args: as })
            | .                             -> { type: #send, target: null, msg: n, args: as }
        )
        | "." n=ident (
            t=tail                          -> set_target(t, { type: #send, target: null, msg: n, args: [] })
            | .                             -> { type: #send, target: null, msg: n, args: [], topcall: true }
        )
    call: fn=value t=tail                   -> set_target(t, fn)

 topargs: a=expr as=(.","@"arg" wsnl expr)* -> as.prepend(a)
 topcall: !"(" fn=ident sp. !"(" (
            a=topcall                       -> { type: #call, target: fn, args: [a] }
            | as=topargs                    -> { type: #call, target: fn, args: as  }
        )
        // certain calls can be used as topcall, e.g. print.call debug.inspect 42
        | !"(" fn=call ?(fn?topcall) sp. !"(" (
            a=topcall                       -> { type: #call, target: fn, args: [a] }
            | as=topargs                    -> { type: #call, target: fn, args: as  }
        )

selfcall: fn=ident                          -> { type: #call, target: fn, args: [] }
    expr: call | value
     stm: e=topcall                      .eostm -> e
        | e=selfcall                     .eostm -> e
        | e=expr     @"end of statement" .eostm -> e

   start: .e=stm.                               -> e
}

print inspect parse("print.call() foo.bar 10, 20")

