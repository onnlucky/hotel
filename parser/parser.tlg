set_target = { call, fn ->
    if not call: return fn
    if not call.target: return _Map_set(call, #target, fn)
    _Map_set(call, #target, set_target(call.target, fn))
}
add_block = { call, block ->
    if not block: return call
    _Map_set(call, #block, block)
}
not_reserved = { name ->
    if name == "null": return false
    if name == "undefined": return false
    if name == "true": return false
    if name == "false": return false
    if name == "not": return false
    if name == "and": return false
    if name == "or": return false
    if name == "xor": return false
    return true
}

var $current_indent = [0]
begin_body = { indent ->
    if indent <= $current_indent.get(0): return false
    $current_indent = $current_indent.prepend(indent)
    return true
}
in_body = { indent, i ->
    return indent <= i
}
end_body = { indent ->
    $current_indent = $current_indent.slice(1)
    return true
}

parse = parser {
      sp: " " | "\t"
      nl: "\r\n" | "\n\r" | "\n" | "\r"

slcomment: "//" (!nl _)*
 icomment: "/*" (!"*/" _)* ("*/"|end)
  comment: (slcomment (nl|end) | icomment)

      ws: (sp | icomment)*
    wsnl: (sp | nl | comment)*

   sepnl: . ("," | nl) wsnl
     eos: . (";" | nl) wsnl
     eov: . ("," | nl) wsnl
   eostm: . (";" | nl | end | ")" | "}" | "]" | slcomment)
  eoexpr: . ("," | ";" | nl | end | ")" | "}" | "]" | slcomment)

nonident: " " | "\n" | "\r" | "\t" | "." | "!" | ":" | ";" | "," | "(" | ")" | "{" | "}" | "[" | "]" | "/" | "\"" | "'"
   first: [_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]
    name: n=first rs=(!nonident _)*  -> rs.prepend(n).toChar
   ident: n=name ?(not_reserved n) -> n.toSym

      op: "or" | "and" | "not"

// ---- TEXT ----

  escape: "\\\""      -> "\""
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\\\"      -> "\\"
        | !"\"" l=_   -> l.toChar
   stext: "\"" ts=escape* @"a closing '\"'" "\"" -> ts.join

   embed: !stext e=paren                  -> { type: #call, target: #_Text_ToText, args: [e] }
    text: l=stext (rss=(.e=embed .t=stext -> [e, t]
                       |.e=embed          -> [e]
                       |.t=stext          -> [t]
                       )+                 -> { type: #call, target: #_Text_Cat, args: rss.reduce({l, r -> l.cat(r)}).prepend(l) }
                  | .                     -> l
                  )

// ---- NUMBERS ----

    sign: "-" -> -1
        | "+" ->  1
        | .   ->  1
     num: s=sign n=numr        -> s * n.reduce({l, r -> l * 10 + r})
    numr: n=numeric "_" b=numr -> b.prepend(n - 48)
        | n=numeric b=numr     -> b.prepend(n - 48)
        | n=numeric            -> [n - 48]

// ---- OBJECT, MAP AND LIST ----

  object: "{" wsnl is=items wsnl @"a closing '}'" "}" -> { type: #OBJECT }
        | "{" wsnl @"a closing '}'" "}"               -> { type: #OBJECT }
     map: "[" wsnl is=items wsnl @"a closing ']'" "]" -> { type: #OBJECT }
        | "[" wsnl ":" wsnl @"a closing ']'" "]"      -> { type: #OBJECT }
   items: i=item eov wsnl is=items
        | i=item
    item: n=name .@"a ':'" ":" wsnl @"a value" v=expr

    list: "[" wsnl is=litems @"a closing ']'" wsnl "]" -> { type: #LIST }
        | "[" wsnl @"a closing ']'" "]"                -> { type: #LIST }
  litems: v=expr eov wsnl is=litems
        | v=expr

// ---- PARSER ----

    this: "@" n=ident -> { type: #self, name: n }

   value: function
        | ident
        | this
        | num | text
        | object | map | list
        | "true"                                   -> true
        | "false"                                  -> false
        | "null"                                   -> { type: #value, value: #null }
        | "undefined"                              -> { type: #value, value: #undefined }

    expr: oplog

   oplog: l=opnot .("or"  wsnl r=oplog       -> { type: #call, target: #or,  args: [l, r] }
                   |"and" wsnl r=oplog       -> { type: #call, target: #and, args: [l, r] }
                   |"xor" wsnl r=oplog       -> { type: #call, target: #xor, args: [l, r] }
                   | .                       -> l
                   )
   opnot: "not" wsnl r=opcmp                 -> { type: #call, target: #not, args: [r] }
        | opcmp
   opcmp: l=opadd .("<=" wsnl r=opcmp        -> { type: #call, target: #lte, args: [l, r] }
                   |"<"  wsnl r=opcmp        -> { type: #call, target: #lt,  args: [l, r] }
                   |">=" wsnl r=opcmp        -> { type: #call, target: #gte, args: [l, r] }
                   |">"  wsnl r=opcmp        -> { type: #call, target: #gt,  args: [l, r] }
                   |"==" wsnl r=opcmp        -> { type: #call, target: #eq,  args: [l, r] }
                   |"!=" wsnl r=opcmp        -> { type: #call, target: #neq, args: [l, r] }
                   | .                       -> l
                   )
   opadd: l=opmul .("+" wsnl r=opadd         -> { type: #call, target: #add, args: [l, r] }
                   |"-" wsnl r=opadd         -> { type: #call, target: #sub, args: [l, r] }
                   | .                       -> l
                   )
   opmul: l=oppow .("*" wsnl r=opmul         -> { type: #call, target: #mul, args: [l, r] }
                   |"/" wsnl r=opmul         -> { type: #call, target: #div, args: [l, r] }
                   |"%" wsnl r=opmul         -> { type: #call, target: #mod, args: [l, r] }
                   | .                       -> l
                   )
   oppow: l=paren .("^" wsnl r=oppow         -> { type: #call, target: #pow, args: [l, r] }
                   | .                       -> l
                   )

   paren: "(". c=stm .")"                          -> c
        | "(".@"closing ')'" wsnl b=body wsnl ")"  -> ts
        | call
        | value

    args: a=expr as=(sepnl expr)*             -> as.prepend(a)
        | .                                   -> []

    tail: "(". @"a closing ')'" as=args .")" t=tail               -> set_target(t, { type: #call, target: null, args: as })
        | "[". l=expr? .":". @"a closing ']'" r=expr? ."]" t=tail -> set_target(t, { type: #send, target: null, msg: #slice, args: [l, r] })
        | "[". @"a closing ']'" e=expr ."]" t=tail                -> set_target(t, { type: #send, target: null, msg: #get, args: [e] })
        | "." n=ident "(". @"a closing ')'" as=args .")" t=tail   -> set_target(t, { type: #send, target: null, msg: n, args: as })
        | "." @"a message" n=ident t=tail                         -> set_target(t, { type: #send, target: null, msg: n, args: [], topcall: true })
        | .                                                       -> null

    call: fn=value t=tail ?(t)                                    -> set_target(t, fn)

 topargs: a=expr as=(.","@"arg" wsnl expr)* -> as.prepend(a)
 topcall: !"(" fn=ident sp. !"(" !op (
              a=topcall                     -> { type: #call, target: fn, args: [a] }
            | as=topargs                    -> { type: #call, target: fn, args: as  }
        )
        // certain calls can be used as topcall, e.g. print.call debug.inspect 42
        | !"(" fn=call ?(fn?topcall) sp. !"(" (
            a=topcall                       -> { type: #call, target: fn, args: [a] }
            | as=topargs                    -> { type: #call, target: fn, args: as  }
        )

function: "{" wsnl as=fargs wsnl "->" wsnl @"a closing '}'"
                b=bodyempty wsnl
          "}"                                  -> { type: #fn, args: as, body: b }
   fargs: a=farg wsnl "," wsnl as=fargs        -> as.prepend(a)
        | a=farg                               -> [a]
        | .                                    -> []
    farg: "&&" n=ident                         -> { type: #collectlazy, name: n }
        | "**" n=ident                         -> { type: #collecteager, name: n }
        | "&" n=ident                          -> { type: #lazy, name: n }
        | n=ident                              -> { type: #eager, name: n }

selfcall: fn=ident                             -> { type: #call, target: fn, args: [] }

     rhs: e=topcall .b=block?            &eostm -> add_block(e, b)
        | e=selfcall .b=block?           &eostm -> add_block(e, b)
        | e=call .b=block?               &eostm -> add_block(e, b)
        | e=expr     @"end of statement" &eostm -> e

   slots: a=slot as=(.",". slot)*               -> as.prepend(a)
    slot: n=ident                               -> { type: #assign, target: n }

     stm: as=slots ."=" wsnl e=rhs              -> [e].cat(as)
        | e=rhs                                 -> [e]

    stms: t=stm ts=(.";".@"statement" stm)*     -> ts.prepend(t).reduce({l, r -> l.cat(r)})

   block: ":" wsnl function
        | ":" wsnl "{" wsnl b=body wsnl "}"     -> b
        | ":" wsnl @"a function or a block" bodynl

    body: ts=stms tss=(wsnl stms)* -> tss.prepend(ts).reduce({l, r -> l.cat(r)})

  bodynl: c=column ?(begin_body c) ts=stms
          tss=(wsnl cc=column ?(in_body c, cc) stms)* ?(end_body c) -> tss.prepend(ts).reduce({l, r -> l.cat(r)})

bodyempty: body
         | .    -> []

   start: wsnl b=bodyempty wsnl end -> b
}

print inspect parse(io.File("test-input.tl").read)

