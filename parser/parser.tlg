set_target = call, fn ->
    if not call: return fn
    if not call.target: return Object.set(call, #target, fn)
    Object.set(call, #target, set_target(call.target, fn))

add_block = call, block ->
    if not block: return call
    Object.set(call, #block, block)

nvalue = name ->
    if name == "null": return false
    if name == "undefined": return false
    if name == "true": return false
    if name == "false": return false
    return true

nreserved = name ->
    if name == "not": return false
    if name == "and": return false
    if name == "or": return false
    return nvalue(name)


var $current_indent = [0]
begin_body = indent ->
    if indent <= $current_indent.get(0): return false
    $current_indent = $current_indent.prepend(indent)
    return true

in_body = indent, i ->
    return indent <= i

end_body = indent ->
    $current_indent = $current_indent.slice(1)
    return true

isTopcall = x ->
    if isNumber x: return false
    if isString x: return false
    return x.topcall

ref = n -> { type: #ref, name: n }

parse = parser {
      sp: " " | "\t"
      nl: "\r\n" | "\n\r" | "\n" | "\r"

slcomment: "//" (!nl _)*
 icomment: "/*" (!"*/" _)* ("*/"|end)
  comment: (slcomment (nl|end) | icomment)

      ws: (sp | icomment)*
    wsnl: (sp | nl | comment)*

     eos: . (";" | nl) ..
     eov: . ("," | .."," | nl) ..
   eostm: . (";" | nl | end | ")" | "}" | "]" | slcomment)
  eoexpr: . ("," | ";" | nl | end | ")" | "}" | "]" | slcomment)

   punct: [ \t\n\r.!:;,=(){}[\]"']
  letter: [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789]
nonident: punct | "/" | "\\" | "<" | ">" | "^"
   first: [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]
    name: n=first rs=(!nonident _)*  -> rs.prepend(n).toChar
   ident: n=name ?(nvalue n) -> n

 opchars: rs=(!letter !punct !"//" _)+ -> rs.toChar
   binop: "or"                        -> #or
        | "and"                       -> #and
        // TODO test n for ^, ~ and others (non binops)
        | !"@" !"$" !"->" n=opchars   -> n
  textop: "or" | "and" | "not"

// ---- TEXT ----

  escape: "\\\""      -> "\""
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\\\"      -> "\\"
        | !"\"" l=_   -> l.toChar
   stext: "\"" ts=escape* @"a closing '\"'" "\"" -> ts.join

   embed: !stext e=paren                  -> { type: #call, target: #_Text_toString, args: [e] }
    text: l=stext (rss=(.e=embed .t=stext -> [e, t]
                       |.e=embed          -> [e]
                       |.t=stext          -> [t]
                       )+                 -> { type: #call, target: #_Text_Cat, args: rss.prepend(l).flatten }
                  | pass                  -> l
                  )

// ---- NUMBERS ----

    sign: "-"  -> -1
        | "+"  ->  1
        | pass ->  1
     num: s=sign n=numr        -> s * n.reduce(l, r -> l * 10 + r)
    numr: n=numeric "_" b=numr -> b.prepend(n - 48)
        | n=numeric b=numr     -> b.prepend(n - 48)
        | n=numeric            -> [n - 48]

// ---- OBJECT, MAP AND LIST ----

  object: "{".. is=items @"a closing '}'" .."}"   -> { type: #object, items: is }
        | "{"..@"a closing '}'" "}"               -> { type: #object, items: [] }
     map: "[".. is=items @"a closing ']'" .."]"   -> { type: #map, items: is }
        | "["..":" @"a closing ']'" .."]"         -> { type: #map, items: [] }
   items: i=item eov.. is=items                   -> is.prepend(i)
        | i=item                                  -> [i]
    item: n=name .@"a ':'" ":"..@"a value" v=expr -> { key: n, value: v }

    list: "[".. is=litems @"a closing ']'" .."]"  -> { type: #list, items: is }
        | "[".."]"                                -> { type: #list, items: [] }
  litems: i=expr !":" eov.. is=litems             -> is.prepend(i)
        | i=expr !":"                             -> [i]

// ---- PARSER ----

    this: "@" n=ident -> { type: #self, name: n }
  varref: "\$" n=ident -> { type: #varref, name: n }

   value: function
        | n=ident                                  -> { type: #ref, name: n }
        | this | varref
        | num | text
        | list | object | map
        | "true"                                   -> true
        | "false"                                  -> false
        | "null"                                   -> { type: #value, value: #null }
        | "undefined"                              -> { type: #value, value: #undefined }

reference: n=name ?(nreserved n)                   -> { type: #ref, name: n }

// TODO this is a bit cludgy ...
    expr: "!"!"=" b=bodynl                         -> { type: #call, target: ref(#vm_task), args: [b] }
        | oplog

   oplog: l=opnot .("or"  .. r=oplog       -> { type: #call, target: ref(#or),  args: [l, r] }
                   |"and" .. r=oplog       -> { type: #call, target: ref(#and), args: [l, r] }
                   | pass                  -> l
                   )
   opnot: "not" .. r=opcmp                 -> { type: #call, target: ref(#not), args: [r] }
        | opcmp
   opcmp: l=opadd .("<=" .. r=opcmp        -> { type: #call, target: ref(#lte), args: [l, r] }
                   |"<"  .. r=opcmp        -> { type: #call, target: ref(#lt),  args: [l, r] }
                   |">=" .. r=opcmp        -> { type: #call, target: ref(#gte), args: [l, r] }
                   |">"  .. r=opcmp        -> { type: #call, target: ref(#gt),  args: [l, r] }
                   |"==" .. r=opcmp        -> { type: #call, target: ref(#eq),  args: [l, r] }
                   |"!=" .. r=opcmp        -> { type: #call, target: ref(#neq), args: [l, r] }
                   | pass                  -> l
                   )
   opadd: l=opmul .("+" .. r=opadd         -> { type: #call, target: ref(#add), args: [l, r] }
                   |"-" .. r=opadd         -> { type: #call, target: ref(#sub), args: [l, r] }
                   | pass                  -> l
                   )
   opmul: l=oppow .("*" .. r=opmul         -> { type: #call, target: ref(#mul), args: [l, r] }
                   |"/" .. r=opmul         -> { type: #call, target: ref(#div), args: [l, r] }
                   |"/|" .. r=opmul        -> { type: #call, target: ref(#idiv), args: [l, r] }
                   |"%" .. r=opmul         -> { type: #call, target: ref(#mod), args: [l, r] }
                   | pass                  -> l
                   )
   oppow: l=paren .("^" .. r=oppow         -> { type: #call, target: ref(#pow), args: [l, r] }
                   | pass                  -> l
                   )

        // the first is an optimization of the second
   paren: "(".. c=stm ..")"                 t=tail -> set_target(t, bool(c.size == 1, c.get(0), c))
        | "(".. @"closing ')'" b=body ..")" t=tail -> set_target(t, b)
        | call
    call: fn=value t=tail                          -> set_target(t, fn)

    args: a=expr as=(eov expr)*             -> as.prepend(a)
        | pass                              -> []

        // the ws is in front, because the empty tail should not eat whitespace, which might be significant
    tail: ."(".. @"a closing ')'" as=args ..")" t=tail                 -> set_target(t, { type: #call, target: null, args: as })
        | ."[".. l=expr? ..":".. @"a closing ']'" r=expr? .."]" t=tail -> set_target(t, { type: #send, target: null, msg: #slice, args: [l, r] })
        | ."[".. @"a closing ']'" e=expr .."]" t=tail                  -> set_target(t, { type: #send, target: null, msg: #get, args: [e] })
        | .".". n=ident ."(".. @"a closing ')'" as=args ..")" t=tail    -> set_target(t, { type: #send, target: null, msg: n, args: as })
        | .".". @"a message" n=ident t=tail                             -> set_target(t, { type: #send, target: null, msg: n, args: [], topcall: true })
        | pass                                                          -> null

 topargs: a=expr as=(.","@"arg".. expr)* -> as.prepend(a)
 topcall: fn=reference sp. !"(" !binop (
              a=topcall                     -> { type: #call, target: fn, args: [a] }
            | as=topargs                    -> { type: #call, target: fn, args: as  }
        )
        // certain calls can be used as topcall, e.g. print.call debug.inspect 42
        // notice, this fn=call backtracks a lot, without caching this sucks ...
        | !"(" !"{" fn=call ?(isTopcall fn) sp. !"(" !binop (
              a=topcall                     -> { type: #call, target: fn, args: [a] }
            | as=topargs                    -> { type: #call, target: fn, args: as  }
        )

function: "(".. as=fargs .."->"..@"a closing ')'"
                b=bodyempty
          ..")"                                   -> { type: #fn, args: as, body: b }
        | "(".. as=fargs .."=>"..@"a closing ')'"
                b=bodyempty
          ..")"                                   -> { type: #block, args: as, body: b }
        | as=fargs ."->".. b=bodynl               -> { type: #fn, args: as, body: b }
        | as=fargs ."=>".. b=bodynl               -> { type: #block, args: as, body: b }


   fargs: a=farg .. "," .. as=fargs        -> as.prepend(a)
        | a=farg                               -> [a]
        | pass                                 -> []
    farg: "&&" n=ident                         -> { type: #collectlazy, name: n }
        | "**" n=ident                         -> { type: #collecteager, name: n }
        | "&" n=ident                          -> { type: #lazy, name: n }
        | n=ident                              -> { type: #eager, name: n }

selfcall: fn=reference                         -> { type: #call, target: fn, args: [] }

     rhs: e=function                     &eostm -> e
        | e=topcall .b=block?            &eostm -> add_block(e, b)
        | e=selfcall .b=block            &eostm -> add_block(e, b)
        | e=call .b=block?               &eostm -> add_block(e, b)
        | e=expr     @"end of statement" &eostm -> e

   slots: a=slot as=(.",". slot)*               -> as.prepend(a)
    slot: "@" n=ident                           -> { type: #selfassign, name: n }
        | "\$" n=ident                          -> { type: #varassign, name: n }
        | "var"."\$" n=ident                    -> { type: #varcreate, name: n }
        | n=ident                               -> { type: #assign, name: n }

     stm: "\$" n=ident .o=binop."=".. e=rhs     -> [{ type: #call, fn: o, args: [{ type: #varref, name: n}, e]}, { type: #varassign, name: n }]
        | "@"  n=ident .o=binop."=".. e=rhs     -> [{ type: #call, fn: o, args: [{ type: #selfref, name: n}, e]}, { type: #selfassign, name: n }]
        | n=ident             ."=".. e=rhs        -> { type: #assign, name: n, value: e }
        //| as=slots          ."=".. e=rhs        -> { type: #multiassign, slots: as, value: e }
        | e=rhs                                 -> [e]

    stms: t=stm ts=(.";".@"statement after ';'" stm)*     -> ts.prepend(t).flatten

   block: ":".. @"a block or function" (
           // this first one is needed, otherwise bodynl will produce paren at a very high indent
             "("..@"a closing ')'" b=body ..")"           -> b
           | function
           | "("..@"a closing ')'" b=body ..")"           -> b
           | bodynl
           )

    body: ts=stms tss=(.. stms)* -> tss.prepend(ts).flatten

  bodynl: c=column ?(begin_body c) ts=stms
          tss=(.. cc=column ?(in_body c, cc) stms)* ?(end_body c) -> tss.prepend(ts).flatten

bodyempty: body
         | pass    -> []

   start: .. b=bodyempty .. end -> b
}

{ parse: parse }

