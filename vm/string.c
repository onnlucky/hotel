// author: Onne Gorter, license: MIT (see license.txt)
// simple str type, wraps a char array with size and tag

#include "trace-off.h"

static tlKind _tlStringKind;
tlKind* tlStringKind = &_tlStringKind;

static tlString* _tl_emptyString;

// TODO short strings should be "inline" saves finalizer
struct tlString {
    tlHead head;
    unsigned int hash;
    unsigned int len;
    const char* data;
};

// returns length of to be returned elements, and fills in (0-based!) offset on where to start
// negative indexes means size - index
// if first < 1 it is corrected to 1
// if last > size it is corrected to size
static int sub_offset(int first, int last, int size, int* offset) {
    trace("before: %d %d (%d): %d", first, last, size, last - first + 1);
    if (first < 0) first = size + first + 1;
    if (first <= 0) first = 1;
    if (first > size) return 0;

    if (last < 0) last = size + last + 1;
    if (last < first) return 0;
    if (last >= size) last = size;

    trace("after: %d %d (%d): %d", first, last, size, last - first + 1);
    if (offset) *offset = first - 1;
    return last - first + 1;
}

// returns offset from index based number
static int at_offset_raw(tlHandle v) {
    if (tlIntIs(v)) return tl_int(v) - 1;
    if (tlFloatIs(v)) return ((int)tl_double(v)) - 1;
    return -1;
}

// returns offset from index based number
static int at_offset(tlHandle v, int size) {
    trace("before: %s (%d)", tl_str(v), size);
    if (!v) return 0;

    int at;
    if (tlIntIs(v)) at = tl_int(v);
    else if (tlFloatIs(v)) at = (int)tl_double(v);
    else return -1;

    if (at < 0) at = size + at + 1;
    if (at <= 0) return -1;
    if (at > size) return -1;
    trace("after: %s (%d)", tl_str(v), size);
    return at - 1;
}

tlString* tlStringEmpty() { return _tl_emptyString; }

tlString* tlStringFromStatic(const char* s, int len) {
    trace("%s", s);
    tlString* str = tlAlloc(tlStringKind, sizeof(tlString));
    str->data = s;
    str->len = (len > 0)?len:strlen(s);
    return str;
}

tlString* tlStringFromTake(char* s, int len) {
    trace("%s", s);
    tlString* str = tlAlloc(tlStringKind, sizeof(tlString));
    str->data = s;
    str->len = (len > 0)?len:strlen(s);
    return str;
}

tlString* tlStringFromCopy(const char* s, int len) {
    trace("%s", s);
    if (len <= 0) len = strlen(s);
    //assert(len < TL_MAX_INT);
    char *data = malloc_atomic(len + 1);
    if (!data) return null;
    memcpy(data, s, len);
    data[len] = 0;
    return tlStringFromTake(data, len);
}

const char* tlStringData(tlString *str) {
    assert(tlStringIs(str));
    return str->data;
}

// TODO this returns the byte size, not the character count! UTF8
int tlStringSize(tlString* str) {
    assert(tlStringIs(str));
    return str->len;
}

#define mmix(h,k) { k *= m; k ^= k >> r; k *= m; h *= m; h ^= k; }
static unsigned int murmurhash2a(const void * key, int len) {
    const unsigned int seed = 33;
    const unsigned int m = 0x5bd1e995;
    const int r = 24;
    unsigned int l = len;
    const unsigned char * data = (const unsigned char *)key;
    unsigned int h = seed;
    while(len >= 4) {
        unsigned int k = *(unsigned int*)data;
        mmix(h,k);
        data += 4;
        len -= 4;
    }
    unsigned int t = 0;
    switch(len) {
        case 3: t ^= data[2] << 16;
        case 2: t ^= data[1] << 8;
        case 1: t ^= data[0];
    }
    mmix(h,t);
    mmix(h,l);
    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;
    return h;
}

unsigned int tlStringHash(tlString* str) {
    assert(tlStringIs(str));
    if (str->hash) return str->hash;
    str->hash = murmurhash2a(str->data, str->len);
    if (!str->hash) str->hash = 1;
    return str->hash;
}
bool tlStringEquals(tlString* left, tlString* right) {
    if (left->len != right->len) return 0;
    if (left->hash && right->hash && left->hash != right->hash) return 0;
    return strcmp(left->data, right->data) == 0;
}
int tlStringCmp(tlString* left, tlString* right) {
    return strcmp(left->data, right->data);
}

tlString* tlStringSub(tlString* from, int offset, int len) {
    if (tlStringSize(from) == len) return from;
    if (len == 0) return tlStringEmpty();

    assert(len > 0);
    assert(offset >= 0);
    assert(offset + len <= tlStringSize(from));

    char* data = malloc_atomic(len + 1);
    memcpy(data, from->data + offset, len);
    data[len] = 0;

    return tlStringFromTake(data, len);
}

tlString* tlStringCat(tlString* left, tlString* right) {
    int size = tlStringSize(left) + tlStringSize(right);
    char* data = malloc_atomic(size + 1);
    if (!data) return null;
    memcpy(data, left->data, tlStringSize(left));
    memcpy(data + tlStringSize(left), right->data, tlStringSize(right));
    data[size] = 0;
    return tlStringFromTake(data, size);
}

// generated by parser for "foo: $foo" etc...
// TODO args.map(_.toString) do it more correctly invoking toString methods
INTERNAL tlHandle _String_cat(tlArgs* args) {
    int argc = tlArgsSize(args);
    trace("%d", argc);
    tlList* list = null;
    int size = 0;
    for (int i = 0; i < argc; i++) {
        tlHandle v = tlArgsGet(args, i);
        trace("%d: %s", i, tl_str(v));
        if (tlStringIs(v)) {
            size += tlStringAs(v)->len;
        } else {
            if (!list) list = tlListNew(argc);
            tlString* str = tlStringFromCopy(tl_str(tlArgsGet(args, i)), 0);
            size += str->len;
            tlListSet_(list, i, str);
        }
    }

    char* data = malloc_atomic(size + 1);
    if (!data) return null;
    size = 0;
    for (int i = 0; i < argc; i++) {
        const char* s;
        int len;
        tlHandle v = tlArgsGet(args, i);
        if (tlStringIs(v)) {
            s = tlStringAs(v)->data;
            len = tlStringAs(v)->len;
        } else {
            tlString* str = tlStringAs(tlListGet(list, i));
            s = str->data;
            len = str->len;
        }
        memcpy(data + size, s, len);
        size += len;
    }
    data[size] = 0;
    return tlStringFromTake(data, size);
}

/// object String: represents a series of characters
/// toString: returns itself
INTERNAL tlHandle _string_toString(tlArgs* args) {
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    return str;
}
/// toSym: create a #Symbol from this #String, throws an error if the string cannot be a valid symbol
INTERNAL tlHandle _string_toSym(tlArgs* args) {
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    return tlSymFromString(str);
}
/// size: return the amount of characters in the #String
INTERNAL tlHandle _string_size(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    return tlINT(tlStringSize(str));
}
/// hash: return the hashcode for this #String
INTERNAL tlHandle _string_hash(tlArgs* args) {
    tlString* str = tlStringCast(tlArgsTarget(args));
    // TODO this can overflow/underflow ... sometimes, need to fix
    return tlINT(tlStringHash(str));
}

/// find: find the first occurance of arg[1] in #String, returns null if not found
INTERNAL tlHandle _string_find(tlArgs* args) {
    tlString* str = tlStringCast(tlArgsTarget(args));
    tlString* find = tlStringCast(tlArgsGet(args, 0));
    if (!find) TL_THROW("expected a String");

    int from = at_offset(tlArgsGet(args, 1), tlStringSize(str));
    if (from < 0) return tlUndef();

    const char* p = strstr(tlStringData(str) + from, tlStringData(find));
    if (!p) return tlUndef();
    return tlINT(1 + p - tlStringData(str));
}

/// cat: concatenate multiple #"String"s together
INTERNAL tlHandle _string_cat(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    tlString* add = tlStringCast(tlArgsGet(args, 0));
    if (!add) TL_THROW("arg must be a String");

    return tlStringCat(str, add);
}

/// get: return character at args[1] characters are just #"Int"s
INTERNAL tlHandle _string_get(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");

    int at = at_offset(tlArgsGet(args, 0), tlStringSize(str));
    if (at < 0) return tlUndef();
    return tlINT(str->data[at]);
}

/// lower: return a new #String with only lower case characters, only works properly for ascii str
INTERNAL tlHandle _string_lower(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    int size = tlStringSize(str);

    tlString* res = tlStringFromCopy(tlStringData(str), size);
    char* buf = (char*)res->data;
    for (int i = 0; i < size; i++) {
        buf[i] = tolower(buf[i]);
    }
    return res;
}

/// upper: return a new #String with all upper case characters, only works properly for ascii str
INTERNAL tlHandle _string_upper(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    int size = tlStringSize(str);

    tlString* res = tlStringFromCopy(tlStringData(str), size);
    char* buf = (char*)res->data;
    for (int i = 0; i < size; i++) {
        buf[i] = toupper(buf[i]);
    }
    return res;
}

/// slice: return a subsection of the #String withing bounds of args[1], args[2]
INTERNAL tlHandle _string_slice(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    int first = tl_int_or(tlArgsGet(args, 0), 1);
    int last = tl_int_or(tlArgsGet(args, 1), -1);

    int offset;
    int len = sub_offset(first, last, tlStringSize(str), &offset);
    return tlStringSub(str, offset, len);
}

static inline char escape(char c) {
    switch (c) {
        case '\0': return '0';
        case '\t': return 't';
        case '\n': return 'n';
        case '\r': return 'r';
        case '"': return '"';
        case '\\': return '\\';
        case '$': return '$';
        default:
            //assert(c >= 32);
            return 0;
    }
}

tlString* tlStringEscape(tlString* str) {
    const char* data = tlStringData(str);
    int size = tlStringSize(str);
    int slashes = 0;
    for (int i = 0; i < size; i++) if (escape(data[i])) slashes++;
    if (slashes == 0) return str;

    char* ndata = malloc(size + slashes + 1);
    int j = 0;
    for (int i = 0; i < size; i++, j++) {
        char c;
        if ((c = escape(data[i]))) {
            ndata[j++] = '\\';
            ndata[j] = c;
        } else {
            ndata[j] = data[i];
        }
    }
    assert(size + slashes == j);
    return tlStringFromTake(ndata, j);
}

/// escape: return a #String that has all special characters escaped by a '\'
INTERNAL tlHandle _string_escape(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    return tlStringEscape(str);
}

/// strip: return a #String that has all leading and trailing whitespace removed (c <= 32)
INTERNAL tlHandle _string_strip(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");

    if (tlStringSize(str) == 0) return str;
    const char* data = tlStringData(str);
    int len = tlStringSize(str);
    int left = 0;
    int right = len; // assuming zero byte at end

    while (left < right && data[left] <= 32) left++;
    while (right > left && data[right] <= 32) right--;
    right++; // always a zero byte

    trace("%d %d", left, right);
    if (left == len) return _tl_emptyString;
    if (left == 0 && right == len) return str;

    int size = right - left;
    assert(size > 0 && size < tlStringSize(str));
    char* ndata = malloc(size + 1);
    memcpy(ndata, data + left, size);
    ndata[size] = 0;
    return tlStringFromTake(ndata, size);
}

static int intmin(int left, int right) { return (left<right)?left:right; }

/// startsWith: return true when this #String begins with the #String in args[1]
INTERNAL tlHandle _string_startsWith(tlArgs* args) {
    tlString* str = tlStringCast(tlArgsTarget(args));
    tlString* start = tlStringCast(tlArgsGet(args, 0));
    if (!start) TL_THROW("arg must be a String");

    int from = at_offset((tlArgsGet(args, 1)), tlStringSize(str));
    if (from == -1) return tlFalse;

    int strsize = tlStringSize(str);
    int startsize = tlStringSize(start);
    if (strsize + from < startsize) return tlFalse;

    int r = strncmp(tlStringData(str) + from, tlStringData(start), startsize);
    return tlBOOL(r == 0);
}

/// endsWith: return true when this #String ends with the #String in args[1]
INTERNAL tlHandle _string_endsWith(tlArgs* args) {
    trace("");
    tlString* str = tlStringCast(tlArgsTarget(args));
    if (!str) TL_THROW("this must be a String");
    tlString* start = tlStringCast(tlArgsGet(args, 0));
    if (!start) TL_THROW("arg must be a String");

    int strsize = tlStringSize(str);
    int startsize = tlStringSize(start);
    if (strsize < startsize) return tlFalse;

    int r = strncmp(tlStringData(str) + strsize - startsize, tlStringData(start), startsize);
    return tlBOOL(r == 0);
}

INTERNAL const char* stringtoString(tlHandle v, char* buf, int size) {
    return tlStringData(tlStringAs(v));
}
INTERNAL unsigned int stringHash(tlHandle v) {
    return tlStringHash(tlStringAs(v));
}
INTERNAL int stringEquals(tlHandle left, tlHandle right) {
    return tlStringEquals(tlStringAs(left), tlStringAs(right));
}
INTERNAL tlHandle stringCmp(tlHandle left, tlHandle right) {
    return tlCOMPARE(tlStringCmp(tlStringAs(left), tlStringAs(right)));
}
static tlKind _tlStringKind = {
    .name = "str",
    .toString = stringtoString,
    .hash = stringHash,
    .equals = stringEquals,
    .cmp = stringCmp,
};

static void string_init() {
    _tl_emptyString = tlSTR("");
    _tlStringKind.klass = tlClassMapFrom(
        "toString", _string_toString,
        "toSym", _string_toSym,
        "size", _string_size,
        "hash", _string_hash,
        "startsWith", _string_startsWith,
        "endsWith", _string_endsWith,
        "find", _string_find,
        "get", _string_get,
        "lower", _string_lower,
        "upper", _string_upper,
        "slice", _string_slice,
        "cat", _string_cat,
        "escape", _string_escape,
        "strip", _string_strip,
        "each", null,
        "map", null,
        "split", null,
        "replace", null,
        "eval", null,
        null
    );
    tlMap* constructor = tlClassMapFrom(
        "call", _String_cat,
        "class", null,
        null
    );
    tlMapSetSym_(constructor, s_class, _tlStringKind.klass);
    tl_register_global("String", constructor);
}

