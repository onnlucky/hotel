// autogenerated:
//   $ cd hotelparser
//   $ make boot
// ** do not edit ** do not edit ** do not edit ** do not edit **
#include "tlmeta.c"

static const char* const colors[] = {"","pad",null};
static State r_wsnl(Parser*, int);
static State r_list_2_1(Parser*, int);
static State r_list_3_1(Parser*, int);
static State r_list_4(Parser*, int);
static State r_list(Parser*, int);
static State r_binn_2_1_1(Parser*, int);
static State r_binn_2_1(Parser*, int);
static State r_binn_3_1_1(Parser*, int);
static State r_binn_3_1(Parser*, int);
static State r_binn_4(Parser*, int);
static State r_binn(Parser*, int);
static State r_object_2_1_1(Parser*, int);
static State r_object_2_1(Parser*, int);
static State r_object_3_1(Parser*, int);
static State r_object_4(Parser*, int);
static State r_object(Parser*, int);
static State r_start(Parser*, int);
static State r_letter(Parser*, int);
static State r_escape_1(Parser*, int);
static State r_escape_2(Parser*, int);
static State r_escape_3(Parser*, int);
static State r_escape_4(Parser*, int);
static State r_escape_5(Parser*, int);
static State r_escape_6_1(Parser*, int);
static State r_escape_6(Parser*, int);
static State r_escape(Parser*, int);
static State r_exp(Parser*, int);
static State r_end_2(Parser*, int);
static State r_end(Parser*, int);
static State r_ws_2(Parser*, int);
static State r_ws(Parser*, int);
static State r_num_1_1(Parser*, int);
static State r_num_1(Parser*, int);
static State r_num_2_1(Parser*, int);
static State r_num_2(Parser*, int);
static State r_num_3(Parser*, int);
static State r_num_4(Parser*, int);
static State r_num(Parser*, int);
static State r_key_1_1(Parser*, int);
static State r_key_1(Parser*, int);
static State r_key(Parser*, int);
static State r_hexn_2_1_1(Parser*, int);
static State r_hexn_2_1(Parser*, int);
static State r_hexn_3_1_1(Parser*, int);
static State r_hexn_3_1(Parser*, int);
static State r_hexn_4(Parser*, int);
static State r_hexn(Parser*, int);
static State r_number_1(Parser*, int);
static State r_number_2(Parser*, int);
static State r_number(Parser*, int);
static State r_value_1(Parser*, int);
static State r_value_2(Parser*, int);
static State r_value_3(Parser*, int);
static State r_value_4(Parser*, int);
static State r_value_5(Parser*, int);
static State r_value_6(Parser*, int);
static State r_value(Parser*, int);
static State r_sep_1(Parser*, int);
static State r_sep_2_1(Parser*, int);
static State r_sep_2_2(Parser*, int);
static State r_sep_2(Parser*, int);
static State r_sep(Parser*, int);
static State r_decn_2_1_1(Parser*, int);
static State r_decn_2_1(Parser*, int);
static State r_decn_3_1_1(Parser*, int);
static State r_decn_3_1(Parser*, int);
static State r_decn_4(Parser*, int);
static State r_decn(Parser*, int);
static State r_string_1_1_1_1(Parser*, int);
static State r_string_1_1_1(Parser*, int);
static State r_string_1(Parser*, int);
static State r_string_2_1_1_1(Parser*, int);
static State r_string_2_1_1(Parser*, int);
static State r_string_2(Parser*, int);
static State r_string(Parser*, int);
static State r_sign_1(Parser*, int);
static State r_sign_2(Parser*, int);
static State r_sign_3(Parser*, int);
static State r_sign(Parser*, int);

static State r_wsnl(Parser* _p, int _start) { // and
 parser_enter(_p, "r_wsnl", _start);
 int _pos = _start;
 State _r = prim_wsnl(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_wsnl", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_wsnl");*/ return _r; }
 return parser_fail(_p, "r_wsnl", _start);
}
static State r_list_2_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_list_2_1", _start);
 int _pos = _start;
 State _r;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_list_2_1", _pos); }
 _pos = _r.pos;
 _r = r_value(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_list_2_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = _r.value;
 return parser_pass(_p, "r_list_2_1", 0, _start, state_ok(_pos, _v));
}
static State r_list_3_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_list_3_1", _start);
 int _pos = _start;
 State _r = r_sep(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_list_3_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_list_3_1");*/ return _r; }
 return parser_fail(_p, "r_list_3_1", _start);
}
static State r_list_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_list_4", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, ",");
 if (_r.ok) return parser_pass(_p, "r_list_4", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_list_4");*/ return _r; }
 return parser_fail(_p, "r_list_4", _start);
}
static State r_list(Parser* _p, int _start) { // and
 parser_enter(_p, "r_list", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "[");
 if (!_r.ok) { return parser_fail(_p, "r_list", _pos); }
 _pos = _r.pos;
 const char* _anchor = parser_set_anchor(_p, "list");
 _r = meta_star(_p, _pos, r_list_2_1, r_list_3_1);
 if (!_r.ok) { return parser_error(_p, "r_list", _start, _pos); }
 _pos = _r.pos;
 tlHandle ls = _r.value;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_error(_p, "r_list", _start, _pos); }
 _pos = _r.pos;
 _r = meta_opt(_p, _pos, r_list_4);
 if (!_r.ok) { return parser_error(_p, "r_list", _start, _pos); }
 _pos = _r.pos;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_error(_p, "r_list", _start, _pos); }
 _pos = _r.pos;
 _r = prim_text(_p, _pos, "]");
 if (!_r.ok) { return parser_error(_p, "r_list", _start, _pos); }
 _pos = _r.pos;
 tlHandle _v = ls;
 _p->anchor = _anchor;
 return parser_pass(_p, "r_list", 0, _start, state_ok(_pos, _v));
}
static State r_binn_2_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_binn_2_1_1", _start);
 int _pos = _start;
 State _r = prim_char(_p, _pos, "01");
 if (_r.ok) return parser_pass(_p, "r_binn_2_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_binn_2_1_1");*/ return _r; }
 return parser_fail(_p, "r_binn_2_1_1", _start);
}
static State r_binn_2_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_binn_2_1", _start);
 int _pos = _start;
 State _r = meta_plus(_p, _pos, r_binn_2_1_1, null);
 if (_r.ok) return parser_pass(_p, "r_binn_2_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_binn_2_1");*/ return _r; }
 return parser_fail(_p, "r_binn_2_1", _start);
}
static State r_binn_3_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_binn_3_1_1", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "_");
 if (_r.ok) return parser_pass(_p, "r_binn_3_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_binn_3_1_1");*/ return _r; }
 return parser_fail(_p, "r_binn_3_1_1", _start);
}
static State r_binn_3_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_binn_3_1", _start);
 int _pos = _start;
 State _r = meta_plus(_p, _pos, r_binn_3_1_1, null);
 if (_r.ok) return parser_pass(_p, "r_binn_3_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_binn_3_1");*/ return _r; }
 return parser_fail(_p, "r_binn_3_1", _start);
}
static State r_binn_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_binn_4", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "_");
 if (_r.ok) return parser_pass(_p, "r_binn_4", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_binn_4");*/ return _r; }
 return parser_fail(_p, "r_binn_4", _start);
}
static State r_binn(Parser* _p, int _start) { // and
 parser_enter(_p, "r_binn", _start);
 int _pos = _start;
 State _r;
 _r = meta_plus(_p, _pos, r_binn_2_1, r_binn_3_1);
 if (!_r.ok) { return parser_fail(_p, "r_binn", _pos); }
 _pos = _r.pos;
 tlHandle n = _r.value;
 _r = meta_not(_p, _pos, r_binn_4);
 if (!_r.ok) { return parser_fail(_p, "r_binn", _pos); }
 _pos = _r.pos;
 tlHandle _v = flatten(n);
 return parser_pass(_p, "r_binn", 0, _start, state_ok(_pos, _v));
}
static State r_object_2_1_1(Parser* _p, int _start) { // or
 parser_enter(_p, "r_object_2_1_1", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, ":");
 if (_r.ok) return parser_pass(_p, "r_object_2_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_object_2_1_1");*/ return _r; }
 _r = prim_text(_p, _pos, "=");
 if (_r.ok) return parser_pass(_p, "r_object_2_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_object_2_1_1");*/ return _r; }
 return parser_fail(_p, "r_object_2_1_1", _start);
}
static State r_object_2_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_object_2_1", _start);
 int _pos = _start;
 State _r;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_object_2_1", _pos); }
 _pos = _r.pos;
 _r = r_key(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_object_2_1", _pos); }
 _pos = _r.pos;
 tlHandle k = _r.value;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_object_2_1", _pos); }
 _pos = _r.pos;
 _r = r_object_2_1_1(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_object_2_1", _pos); }
 _pos = _r.pos;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_object_2_1", _pos); }
 _pos = _r.pos;
 _r = r_value(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_object_2_1", _pos); }
 _pos = _r.pos;
 tlHandle v = _r.value;
 tlHandle _v = tlObjectFrom("k", k, "v", v, null);
 return parser_pass(_p, "r_object_2_1", 0, _start, state_ok(_pos, _v));
}
static State r_object_3_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_object_3_1", _start);
 int _pos = _start;
 State _r = r_sep(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_object_3_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_object_3_1");*/ return _r; }
 return parser_fail(_p, "r_object_3_1", _start);
}
static State r_object_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_object_4", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, ",");
 if (_r.ok) return parser_pass(_p, "r_object_4", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_object_4");*/ return _r; }
 return parser_fail(_p, "r_object_4", _start);
}
static State r_object(Parser* _p, int _start) { // and
 parser_enter(_p, "r_object", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "{");
 if (!_r.ok) { return parser_fail(_p, "r_object", _pos); }
 _pos = _r.pos;
 const char* _anchor = parser_set_anchor(_p, "object");
 _r = meta_star(_p, _pos, r_object_2_1, r_object_3_1);
 if (!_r.ok) { return parser_error(_p, "r_object", _start, _pos); }
 _pos = _r.pos;
 tlHandle kv = _r.value;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_error(_p, "r_object", _start, _pos); }
 _pos = _r.pos;
 _r = meta_opt(_p, _pos, r_object_4);
 if (!_r.ok) { return parser_error(_p, "r_object", _start, _pos); }
 _pos = _r.pos;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_error(_p, "r_object", _start, _pos); }
 _pos = _r.pos;
 _r = prim_text(_p, _pos, "}");
 if (!_r.ok) { return parser_error(_p, "r_object", _start, _pos); }
 _pos = _r.pos;
 tlHandle _v = Object(kv);
 _p->anchor = _anchor;
 return parser_pass(_p, "r_object", 0, _start, state_ok(_pos, _v));
}
static State r_start(Parser* _p, int _start) { // and
 parser_enter(_p, "r_start", _start);
 int _pos = _start;
 State _r;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_start", _pos); }
 _pos = _r.pos;
 _r = r_value(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_start", _pos); }
 _pos = _r.pos;
 tlHandle v = _r.value;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_start", _pos); }
 _pos = _r.pos;
 _r = r_end(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_start", _pos); }
 _pos = _r.pos;
 tlHandle _v = v;
 return parser_pass(_p, "r_start", 0, _start, state_ok(_pos, _v));
}
static State r_letter(Parser* _p, int _start) { // and
 parser_enter(_p, "r_letter", _start);
 int _pos = _start;
 State _r = prim_char(_p, _pos, "$@_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
 if (_r.ok) return parser_pass(_p, "r_letter", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_letter");*/ return _r; }
 return parser_fail(_p, "r_letter", _start);
}
static State r_escape_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_escape_1", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "\\\"");
 if (!_r.ok) { return parser_fail(_p, "r_escape_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT('"');
 return parser_pass(_p, "r_escape_1", 0, _start, state_ok(_pos, _v));
}
static State r_escape_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_escape_2", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "\\n");
 if (!_r.ok) { return parser_fail(_p, "r_escape_2", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT('\n');
 return parser_pass(_p, "r_escape_2", 0, _start, state_ok(_pos, _v));
}
static State r_escape_3(Parser* _p, int _start) { // and
 parser_enter(_p, "r_escape_3", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "\\r");
 if (!_r.ok) { return parser_fail(_p, "r_escape_3", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT('\r');
 return parser_pass(_p, "r_escape_3", 0, _start, state_ok(_pos, _v));
}
static State r_escape_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_escape_4", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "\\t");
 if (!_r.ok) { return parser_fail(_p, "r_escape_4", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT('\t');
 return parser_pass(_p, "r_escape_4", 0, _start, state_ok(_pos, _v));
}
static State r_escape_5(Parser* _p, int _start) { // and
 parser_enter(_p, "r_escape_5", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "\\\\");
 if (!_r.ok) { return parser_fail(_p, "r_escape_5", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT('\\');
 return parser_pass(_p, "r_escape_5", 0, _start, state_ok(_pos, _v));
}
static State r_escape_6_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_escape_6_1", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "\"");
 if (_r.ok) return parser_pass(_p, "r_escape_6_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_escape_6_1");*/ return _r; }
 return parser_fail(_p, "r_escape_6_1", _start);
}
static State r_escape_6(Parser* _p, int _start) { // and
 parser_enter(_p, "r_escape_6", _start);
 int _pos = _start;
 State _r;
 _r = meta_not(_p, _pos, r_escape_6_1);
 if (!_r.ok) { return parser_fail(_p, "r_escape_6", _pos); }
 _pos = _r.pos;
 _r = prim_any(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_escape_6", _pos); }
 _pos = _r.pos;
 tlHandle _v = _r.value;
 return parser_pass(_p, "r_escape_6", 0, _start, state_ok(_pos, _v));
}
static State r_escape(Parser* _p, int _start) { // or
 parser_enter(_p, "r_escape", _start);
 int _pos = _start;
 State _r;
 _r = r_escape_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_escape", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_escape");*/ return _r; }
 _r = r_escape_2(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_escape", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_escape");*/ return _r; }
 _r = r_escape_3(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_escape", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_escape");*/ return _r; }
 _r = r_escape_4(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_escape", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_escape");*/ return _r; }
 _r = r_escape_5(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_escape", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_escape");*/ return _r; }
 _r = r_escape_6(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_escape", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_escape");*/ return _r; }
 return parser_fail(_p, "r_escape", _start);
}
static State r_exp(Parser* _p, int _start) { // and
 parser_enter(_p, "r_exp", _start);
 int _pos = _start;
 State _r;
 _r = prim_char(_p, _pos, "Ee");
 if (!_r.ok) { return parser_fail(_p, "r_exp", _pos); }
 _pos = _r.pos;
 _r = r_sign(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_exp", _pos); }
 _pos = _r.pos;
 tlHandle s = _r.value;
 _r = r_decn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_exp", _pos); }
 _pos = _r.pos;
 tlHandle w = _r.value;
 tlHandle _v = Number(s, w, 10);
 return parser_pass(_p, "r_exp", 0, _start, state_ok(_pos, _v));
}
static State r_end_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_end_2", _start);
 int _pos = _start;
 State _r = prim_any(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_end_2", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_end_2");*/ return _r; }
 return parser_fail(_p, "r_end_2", _start);
}
static State r_end(Parser* _p, int _start) { // and
 parser_enter(_p, "r_end", _start);
 int _pos = _start;
 State _r = meta_not(_p, _pos, r_end_2);
 if (_r.ok) return parser_pass(_p, "r_end", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_end");*/ return _r; }
 return parser_fail(_p, "r_end", _start);
}
static State r_ws_2(Parser* _p, int _start) { // or
 parser_enter(_p, "r_ws_2", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, " ");
 if (_r.ok) return parser_pass(_p, "r_ws_2", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_ws_2");*/ return _r; }
 _r = prim_text(_p, _pos, "\t");
 if (_r.ok) return parser_pass(_p, "r_ws_2", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_ws_2");*/ return _r; }
 _r = prim_text(_p, _pos, "\r");
 if (_r.ok) return parser_pass(_p, "r_ws_2", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_ws_2");*/ return _r; }
 _r = prim_text(_p, _pos, "\n");
 if (_r.ok) return parser_pass(_p, "r_ws_2", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_ws_2");*/ return _r; }
 return parser_fail(_p, "r_ws_2", _start);
}
static State r_ws(Parser* _p, int _start) { // and
 parser_enter(_p, "r_ws", _start);
 int _pos = _start;
 State _r = meta_star(_p, _pos, r_ws_2, null);
 if (_r.ok) return parser_pass(_p, "r_ws", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_ws");*/ return _r; }
 return parser_fail(_p, "r_ws", _start);
}
static State r_num_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_num_1_1", _start);
 int _pos = _start;
 State _r = r_exp(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_num_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_num_1_1");*/ return _r; }
 return parser_fail(_p, "r_num_1_1", _start);
}
static State r_num_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_num_1", _start);
 int _pos = _start;
 State _r;
 _r = r_sign(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_1", _pos); }
 _pos = _r.pos;
 tlHandle s = _r.value;
 _r = r_decn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_1", _pos); }
 _pos = _r.pos;
 tlHandle w = _r.value;
 _r = prim_text(_p, _pos, ".");
 if (!_r.ok) { return parser_fail(_p, "r_num_1", _pos); }
 _pos = _r.pos;
 _r = r_decn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_1", _pos); }
 _pos = _r.pos;
 tlHandle f = _r.value;
 _r = meta_opt(_p, _pos, r_num_1_1);
 if (!_r.ok) { return parser_fail(_p, "r_num_1", _pos); }
 _pos = _r.pos;
 tlHandle e = _r.value;
 tlHandle _v = FloatExp(s, w, f, e);
 return parser_pass(_p, "r_num_1", 0, _start, state_ok(_pos, _v));
}
static State r_num_2_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_num_2_1", _start);
 int _pos = _start;
 State _r = r_exp(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_num_2_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_num_2_1");*/ return _r; }
 return parser_fail(_p, "r_num_2_1", _start);
}
static State r_num_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_num_2", _start);
 int _pos = _start;
 State _r;
 _r = r_sign(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_2", _pos); }
 _pos = _r.pos;
 tlHandle s = _r.value;
 _r = prim_text(_p, _pos, ".");
 if (!_r.ok) { return parser_fail(_p, "r_num_2", _pos); }
 _pos = _r.pos;
 _r = r_decn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_2", _pos); }
 _pos = _r.pos;
 tlHandle f = _r.value;
 _r = meta_opt(_p, _pos, r_num_2_1);
 if (!_r.ok) { return parser_fail(_p, "r_num_2", _pos); }
 _pos = _r.pos;
 tlHandle e = _r.value;
 tlHandle _v = FloatExp(s, null, f, e);
 return parser_pass(_p, "r_num_2", 0, _start, state_ok(_pos, _v));
}
static State r_num_3(Parser* _p, int _start) { // and
 parser_enter(_p, "r_num_3", _start);
 int _pos = _start;
 State _r;
 _r = r_sign(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_3", _pos); }
 _pos = _r.pos;
 tlHandle s = _r.value;
 _r = r_decn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_3", _pos); }
 _pos = _r.pos;
 tlHandle w = _r.value;
 _r = r_exp(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_3", _pos); }
 _pos = _r.pos;
 tlHandle e = _r.value;
 tlHandle _v = FloatExp(s, w, null, e);
 return parser_pass(_p, "r_num_3", 0, _start, state_ok(_pos, _v));
}
static State r_num_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_num_4", _start);
 int _pos = _start;
 State _r;
 _r = r_sign(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_4", _pos); }
 _pos = _r.pos;
 tlHandle s = _r.value;
 _r = r_decn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_num_4", _pos); }
 _pos = _r.pos;
 tlHandle w = _r.value;
 tlHandle _v = Number(s, w, 10);
 return parser_pass(_p, "r_num_4", 0, _start, state_ok(_pos, _v));
}
static State r_num(Parser* _p, int _start) { // or
 parser_enter(_p, "r_num", _start);
 int _pos = _start;
 State _r;
 _r = r_num_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_num", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_num");*/ return _r; }
 _r = r_num_2(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_num", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_num");*/ return _r; }
 _r = r_num_3(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_num", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_num");*/ return _r; }
 _r = r_num_4(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_num", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_num");*/ return _r; }
 return parser_fail(_p, "r_num", _start);
}
static State r_key_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_key_1_1", _start);
 int _pos = _start;
 State _r = r_letter(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_key_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_key_1_1");*/ return _r; }
 return parser_fail(_p, "r_key_1_1", _start);
}
static State r_key_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_key_1", _start);
 int _pos = _start;
 State _r;
 _r = meta_plus(_p, _pos, r_key_1_1, null);
 if (!_r.ok) { return parser_fail(_p, "r_key_1", _pos); }
 _pos = _r.pos;
 tlHandle ts = _r.value;
 tlHandle _v = String(ts);
 return parser_pass(_p, "r_key_1", 0, _start, state_ok(_pos, _v));
}
static State r_key(Parser* _p, int _start) { // or
 parser_enter(_p, "r_key", _start);
 int _pos = _start;
 State _r;
 _r = r_string(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_key", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_key");*/ return _r; }
 _r = r_key_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_key", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_key");*/ return _r; }
 return parser_fail(_p, "r_key", _start);
}
static State r_hexn_2_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_hexn_2_1_1", _start);
 int _pos = _start;
 State _r = prim_char(_p, _pos, "0123456789ABCDEFGabcdefg");
 if (_r.ok) return parser_pass(_p, "r_hexn_2_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_hexn_2_1_1");*/ return _r; }
 return parser_fail(_p, "r_hexn_2_1_1", _start);
}
static State r_hexn_2_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_hexn_2_1", _start);
 int _pos = _start;
 State _r = meta_plus(_p, _pos, r_hexn_2_1_1, null);
 if (_r.ok) return parser_pass(_p, "r_hexn_2_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_hexn_2_1");*/ return _r; }
 return parser_fail(_p, "r_hexn_2_1", _start);
}
static State r_hexn_3_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_hexn_3_1_1", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "_");
 if (_r.ok) return parser_pass(_p, "r_hexn_3_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_hexn_3_1_1");*/ return _r; }
 return parser_fail(_p, "r_hexn_3_1_1", _start);
}
static State r_hexn_3_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_hexn_3_1", _start);
 int _pos = _start;
 State _r = meta_plus(_p, _pos, r_hexn_3_1_1, null);
 if (_r.ok) return parser_pass(_p, "r_hexn_3_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_hexn_3_1");*/ return _r; }
 return parser_fail(_p, "r_hexn_3_1", _start);
}
static State r_hexn_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_hexn_4", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "_");
 if (_r.ok) return parser_pass(_p, "r_hexn_4", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_hexn_4");*/ return _r; }
 return parser_fail(_p, "r_hexn_4", _start);
}
static State r_hexn(Parser* _p, int _start) { // and
 parser_enter(_p, "r_hexn", _start);
 int _pos = _start;
 State _r;
 _r = meta_plus(_p, _pos, r_hexn_2_1, r_hexn_3_1);
 if (!_r.ok) { return parser_fail(_p, "r_hexn", _pos); }
 _pos = _r.pos;
 tlHandle n = _r.value;
 _r = meta_not(_p, _pos, r_hexn_4);
 if (!_r.ok) { return parser_fail(_p, "r_hexn", _pos); }
 _pos = _r.pos;
 tlHandle _v = flatten(n);
 return parser_pass(_p, "r_hexn", 0, _start, state_ok(_pos, _v));
}
static State r_number_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_number_1", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "0x");
 if (!_r.ok) { return parser_fail(_p, "r_number_1", _pos); }
 _pos = _r.pos;
 _r = r_hexn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_number_1", _pos); }
 _pos = _r.pos;
 tlHandle w = _r.value;
 tlHandle _v = Number(null, w, 16);
 return parser_pass(_p, "r_number_1", 0, _start, state_ok(_pos, _v));
}
static State r_number_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_number_2", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "0b");
 if (!_r.ok) { return parser_fail(_p, "r_number_2", _pos); }
 _pos = _r.pos;
 _r = r_binn(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_number_2", _pos); }
 _pos = _r.pos;
 tlHandle w = _r.value;
 tlHandle _v = Number(null, w, 2);
 return parser_pass(_p, "r_number_2", 0, _start, state_ok(_pos, _v));
}
static State r_number(Parser* _p, int _start) { // or
 parser_enter(_p, "r_number", _start);
 int _pos = _start;
 State _r;
 _r = r_number_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_number", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_number");*/ return _r; }
 _r = r_number_2(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_number", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_number");*/ return _r; }
 _r = r_num(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_number", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_number");*/ return _r; }
 return parser_fail(_p, "r_number", _start);
}
static State r_value_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_value_1", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "null");
 if (!_r.ok) { return parser_fail(_p, "r_value_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlNull;
 return parser_pass(_p, "r_value_1", 0, _start, state_ok(_pos, _v));
}
static State r_value_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_value_2", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "false");
 if (!_r.ok) { return parser_fail(_p, "r_value_2", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlFalse;
 return parser_pass(_p, "r_value_2", 0, _start, state_ok(_pos, _v));
}
static State r_value_3(Parser* _p, int _start) { // and
 parser_enter(_p, "r_value_3", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "true");
 if (!_r.ok) { return parser_fail(_p, "r_value_3", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlTrue;
 return parser_pass(_p, "r_value_3", 0, _start, state_ok(_pos, _v));
}
static State r_value_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_value_4", _start);
 int _pos = _start;
 State _r;
 _r = prim_char(_p, _pos, "Nn");
 if (!_r.ok) { return parser_fail(_p, "r_value_4", _pos); }
 _pos = _r.pos;
 _r = prim_char(_p, _pos, "Aa");
 if (!_r.ok) { return parser_fail(_p, "r_value_4", _pos); }
 _pos = _r.pos;
 _r = prim_char(_p, _pos, "Nn");
 if (!_r.ok) { return parser_fail(_p, "r_value_4", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlNull;
 return parser_pass(_p, "r_value_4", 0, _start, state_ok(_pos, _v));
}
static State r_value_5(Parser* _p, int _start) { // and
 parser_enter(_p, "r_value_5", _start);
 int _pos = _start;
 State _r;
 _r = prim_char(_p, _pos, "Ii");
 if (!_r.ok) { return parser_fail(_p, "r_value_5", _pos); }
 _pos = _r.pos;
 _r = prim_char(_p, _pos, "Nn");
 if (!_r.ok) { return parser_fail(_p, "r_value_5", _pos); }
 _pos = _r.pos;
 _r = prim_char(_p, _pos, "Ff");
 if (!_r.ok) { return parser_fail(_p, "r_value_5", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlNull;
 return parser_pass(_p, "r_value_5", 0, _start, state_ok(_pos, _v));
}
static State r_value_6(Parser* _p, int _start) { // and
 parser_enter(_p, "r_value_6", _start);
 int _pos = _start;
 State _r;
 _r = prim_char(_p, _pos, "-+");
 if (!_r.ok) { return parser_fail(_p, "r_value_6", _pos); }
 _pos = _r.pos;
 _r = prim_char(_p, _pos, "Ii");
 if (!_r.ok) { return parser_fail(_p, "r_value_6", _pos); }
 _pos = _r.pos;
 _r = prim_char(_p, _pos, "Nn");
 if (!_r.ok) { return parser_fail(_p, "r_value_6", _pos); }
 _pos = _r.pos;
 _r = prim_char(_p, _pos, "Ff");
 if (!_r.ok) { return parser_fail(_p, "r_value_6", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlNull;
 return parser_pass(_p, "r_value_6", 0, _start, state_ok(_pos, _v));
}
static State r_value(Parser* _p, int _start) { // or
 parser_enter(_p, "r_value", _start);
 int _pos = _start;
 State _r;
 _r = r_value_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_value_2(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_value_3(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_value_4(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_value_5(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_value_6(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_num(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_string(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_list(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 _r = r_object(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_value", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_value");*/ return _r; }
 return parser_fail(_p, "r_value", _start);
}
static State r_sep_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_sep_1", _start);
 int _pos = _start;
 State _r;
 _r = r_ws(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_sep_1", _pos); }
 _pos = _r.pos;
 _r = prim_text(_p, _pos, ",");
 if (!_r.ok) { return parser_fail(_p, "r_sep_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = _r.value;
 return parser_pass(_p, "r_sep_1", 0, _start, state_ok(_pos, _v));
}
static State r_sep_2_1(Parser* _p, int _start) { // or
 parser_enter(_p, "r_sep_2_1", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, " ");
 if (_r.ok) return parser_pass(_p, "r_sep_2_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sep_2_1");*/ return _r; }
 _r = prim_text(_p, _pos, "\t");
 if (_r.ok) return parser_pass(_p, "r_sep_2_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sep_2_1");*/ return _r; }
 return parser_fail(_p, "r_sep_2_1", _start);
}
static State r_sep_2_2(Parser* _p, int _start) { // or
 parser_enter(_p, "r_sep_2_2", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "\n");
 if (_r.ok) return parser_pass(_p, "r_sep_2_2", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sep_2_2");*/ return _r; }
 _r = prim_text(_p, _pos, "\r");
 if (_r.ok) return parser_pass(_p, "r_sep_2_2", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sep_2_2");*/ return _r; }
 return parser_fail(_p, "r_sep_2_2", _start);
}
static State r_sep_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_sep_2", _start);
 int _pos = _start;
 State _r;
 _r = meta_star(_p, _pos, r_sep_2_1, null);
 if (!_r.ok) { return parser_fail(_p, "r_sep_2", _pos); }
 _pos = _r.pos;
 _r = r_sep_2_2(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_sep_2", _pos); }
 _pos = _r.pos;
 tlHandle _v = _r.value;
 return parser_pass(_p, "r_sep_2", 0, _start, state_ok(_pos, _v));
}
static State r_sep(Parser* _p, int _start) { // or
 parser_enter(_p, "r_sep", _start);
 int _pos = _start;
 State _r;
 _r = r_sep_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_sep", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sep");*/ return _r; }
 _r = r_sep_2(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_sep", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sep");*/ return _r; }
 return parser_fail(_p, "r_sep", _start);
}
static State r_decn_2_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_decn_2_1_1", _start);
 int _pos = _start;
 State _r = prim_char(_p, _pos, "0123456789");
 if (_r.ok) return parser_pass(_p, "r_decn_2_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_decn_2_1_1");*/ return _r; }
 return parser_fail(_p, "r_decn_2_1_1", _start);
}
static State r_decn_2_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_decn_2_1", _start);
 int _pos = _start;
 State _r = meta_plus(_p, _pos, r_decn_2_1_1, null);
 if (_r.ok) return parser_pass(_p, "r_decn_2_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_decn_2_1");*/ return _r; }
 return parser_fail(_p, "r_decn_2_1", _start);
}
static State r_decn_3_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_decn_3_1_1", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "_");
 if (_r.ok) return parser_pass(_p, "r_decn_3_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_decn_3_1_1");*/ return _r; }
 return parser_fail(_p, "r_decn_3_1_1", _start);
}
static State r_decn_3_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_decn_3_1", _start);
 int _pos = _start;
 State _r = meta_plus(_p, _pos, r_decn_3_1_1, null);
 if (_r.ok) return parser_pass(_p, "r_decn_3_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_decn_3_1");*/ return _r; }
 return parser_fail(_p, "r_decn_3_1", _start);
}
static State r_decn_4(Parser* _p, int _start) { // and
 parser_enter(_p, "r_decn_4", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "_");
 if (_r.ok) return parser_pass(_p, "r_decn_4", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_decn_4");*/ return _r; }
 return parser_fail(_p, "r_decn_4", _start);
}
static State r_decn(Parser* _p, int _start) { // and
 parser_enter(_p, "r_decn", _start);
 int _pos = _start;
 State _r;
 _r = meta_plus(_p, _pos, r_decn_2_1, r_decn_3_1);
 if (!_r.ok) { return parser_fail(_p, "r_decn", _pos); }
 _pos = _r.pos;
 tlHandle n = _r.value;
 _r = meta_not(_p, _pos, r_decn_4);
 if (!_r.ok) { return parser_fail(_p, "r_decn", _pos); }
 _pos = _r.pos;
 tlHandle _v = flatten(n);
 return parser_pass(_p, "r_decn", 0, _start, state_ok(_pos, _v));
}
static State r_string_1_1_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_string_1_1_1_1", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "\"");
 if (_r.ok) return parser_pass(_p, "r_string_1_1_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_string_1_1_1_1");*/ return _r; }
 return parser_fail(_p, "r_string_1_1_1_1", _start);
}
static State r_string_1_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_string_1_1_1", _start);
 int _pos = _start;
 State _r;
 _r = meta_not(_p, _pos, r_string_1_1_1_1);
 if (!_r.ok) { return parser_fail(_p, "r_string_1_1_1", _pos); }
 _pos = _r.pos;
 _r = r_escape(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_string_1_1_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = _r.value;
 return parser_pass(_p, "r_string_1_1_1", 0, _start, state_ok(_pos, _v));
}
static State r_string_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_string_1", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "\"");
 if (!_r.ok) { return parser_fail(_p, "r_string_1", _pos); }
 _pos = _r.pos;
 _r = meta_star(_p, _pos, r_string_1_1_1, null);
 if (!_r.ok) { return parser_fail(_p, "r_string_1", _pos); }
 _pos = _r.pos;
 tlHandle ts = _r.value;
 _r = prim_text(_p, _pos, "\"");
 if (!_r.ok) { return parser_fail(_p, "r_string_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = String(ts);
 return parser_pass(_p, "r_string_1", 0, _start, state_ok(_pos, _v));
}
static State r_string_2_1_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_string_2_1_1_1", _start);
 int _pos = _start;
 State _r = prim_text(_p, _pos, "'");
 if (_r.ok) return parser_pass(_p, "r_string_2_1_1_1", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_string_2_1_1_1");*/ return _r; }
 return parser_fail(_p, "r_string_2_1_1_1", _start);
}
static State r_string_2_1_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_string_2_1_1", _start);
 int _pos = _start;
 State _r;
 _r = meta_not(_p, _pos, r_string_2_1_1_1);
 if (!_r.ok) { return parser_fail(_p, "r_string_2_1_1", _pos); }
 _pos = _r.pos;
 _r = r_escape(_p, _pos);
 if (!_r.ok) { return parser_fail(_p, "r_string_2_1_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = _r.value;
 return parser_pass(_p, "r_string_2_1_1", 0, _start, state_ok(_pos, _v));
}
static State r_string_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_string_2", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "'");
 if (!_r.ok) { return parser_fail(_p, "r_string_2", _pos); }
 _pos = _r.pos;
 _r = meta_star(_p, _pos, r_string_2_1_1, null);
 if (!_r.ok) { return parser_fail(_p, "r_string_2", _pos); }
 _pos = _r.pos;
 tlHandle ts = _r.value;
 _r = prim_text(_p, _pos, "'");
 if (!_r.ok) { return parser_fail(_p, "r_string_2", _pos); }
 _pos = _r.pos;
 tlHandle _v = String(ts);
 return parser_pass(_p, "r_string_2", 0, _start, state_ok(_pos, _v));
}
static State r_string(Parser* _p, int _start) { // or
 parser_enter(_p, "r_string", _start);
 int _pos = _start;
 State _r;
 _r = r_string_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_string", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_string");*/ return _r; }
 _r = r_string_2(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_string", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_string");*/ return _r; }
 return parser_fail(_p, "r_string", _start);
}
static State r_sign_1(Parser* _p, int _start) { // and
 parser_enter(_p, "r_sign_1", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "-");
 if (!_r.ok) { return parser_fail(_p, "r_sign_1", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT(-1);
 return parser_pass(_p, "r_sign_1", 0, _start, state_ok(_pos, _v));
}
static State r_sign_2(Parser* _p, int _start) { // and
 parser_enter(_p, "r_sign_2", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "+");
 if (!_r.ok) { return parser_fail(_p, "r_sign_2", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT(1);
 return parser_pass(_p, "r_sign_2", 0, _start, state_ok(_pos, _v));
}
static State r_sign_3(Parser* _p, int _start) { // and
 parser_enter(_p, "r_sign_3", _start);
 int _pos = _start;
 State _r;
 _r = prim_text(_p, _pos, "");
 if (!_r.ok) { return parser_fail(_p, "r_sign_3", _pos); }
 _pos = _r.pos;
 tlHandle _v = tlINT(1);
 return parser_pass(_p, "r_sign_3", 0, _start, state_ok(_pos, _v));
}
static State r_sign(Parser* _p, int _start) { // or
 parser_enter(_p, "r_sign", _start);
 int _pos = _start;
 State _r;
 _r = r_sign_1(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_sign", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sign");*/ return _r; }
 _r = r_sign_2(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_sign", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sign");*/ return _r; }
 _r = r_sign_3(_p, _pos);
 if (_r.ok) return parser_pass(_p, "r_sign", 0, _start, _r);
 if (_p->error_line) { /*print("expect: r_sign");*/ return _r; }
 return parser_fail(_p, "r_sign", _start);
}

#ifndef NO_VALUE
static tlHandle _json_parse(tlArgs* args) {
    tlString* code = tlStringCast(tlArgsGet(args, 0));
    if (!code) TL_THROW("expected a String");
    Parser* p = parser_new(tlStringData(code), tlStringSize(code));
    bool r = parser_parse(p, r_start);
    if (!r) {
        TL_THROW("parse error: %s at: %d:%d", p->error_msg, p->error_line, p->error_char);
    }
    return p->value;
}

void jsonparser_init() {
    tl_register_global("_json_parse", tlNATIVE(_json_parse, "_json_parse"));
}
#endif

