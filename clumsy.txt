# undefined properties throw

  foo.bar

will throw undefined, which is great, but sometimes you just need to "test"

how about

  foo?bar

is basically short (and fast) for:
  (
    _catch: e -> null
    foo?bar
  )

# throw/catch

need to be able to catch only specific type of error

# toText and instanceof

somehow, Buffer.toBuffer will wish to inspect if other is a buffer object but without knowing it actually is a buffer ...

how about:
  Buffer.toBuffer = (val ->
     return val?asBuffer or Buffer.new(val.toText)
  )

but now we "fixed" asBuffer to io.Buffer ... maybe others wish to do toBuffer too but in different context

probably that is workable, if ever objects are mixed up in two contexts errors will be thrown anyway, and you can factor your object in two pieces ...

