# TODO

clean op operators and comments:
    pow: 2**2 = 4
    xor: 2 ^ 2 == 0
    div: 8 / 16 = 0.5
    intdiv: 8 // 16 = 0
    floatdiv: 8 /. 16 == 8 / 16f == 8f / 16 == 0.5000000000001
    # single line comment
    ### multi line comment, only if at beginning of line
    (# ... #) nesting multiline comment

think about array access as list(1) instead of list[1]?? and then list(1) = 10? map("foo") = 10, Object.set(object, "foo") = 10
fix/finish modules, should load them relative to current module, then Task.locals, then TL_MODULE_PATH; should be able to call them as functions, as well as get their results

rework compile, all .c files should have .h file and compile to .o file

allow tlEnv to have imports, so that before mod->links[global] we look up global against all scoped imports first
add tlClass with mixins and super and fields and methods, all primitives should have a tlClass
implement proper operators and "hello" is String stuff
add import to env
add way to extend objects within the current scope

optimize code->argspec
optimize code->hasLazy
perhaps add args->names.last as object that maps symbol to args->names index

add something for 'collection["key", otherwise]' but will be part of get interface then
think about shared locks, so whole slew of items share single lock, especially helpful for Mutable objects
think about {call:42} meaning something different from {foo:42} and perhaps remove that "meaning" by only making call special if "object" with a "class"
implement a true class based object, vs value objects, vs maps

undefined collect stack traces, while it doesn't work as advertised ... either enhance or dumb down
tool gcov and assure make test has full coverage
work on documentation
add optional types turning into asserts, experiment with compiler discovering types
null > 1: throw undefined? or return undefined?
graphics: turn into module, by registering a vm exit function and moving vm to alternative thread
graphics: don't do the thread/blocking/reentrance dance, instead, have a single task driving native API

bytecode
- in bytecode, we don't need argnames, we can calculate and store that map when we need it, als we can size the args list dynamically, saves space ...
- implement classes in parser, compiler
- ensure debugger works
- have a coverage tool
- do simple optimizations in compiler, like (x + 1) * 2 does not require a body for x + 1

guarded expressions: think about a better syntax?

add "if"/"unless" to parser to do
- return if true
- return unless true
- if(true,something,otherwise)
do we want a true else? or just use guarded expressions?

add xml like things to language

add a WeakMap, add a HashMap based on regular locked hashmap implementation

add kind->resume for tlFrame and throw using frame.kind.name

do class._name for error.toString: this.class._name ": " this.msg ...
on error, if object, call toString on it ...

simplify usage of libgc/libatomic_ops, it takes way to long to configure/compile?
implement a_var based on libatomic_ops ...

what about "deamon tasks" ... how can that work? maybe those don't go into io waiting?

implement print in user code, or have it call toString properly ...
do errors with nice backtraces per file etc, and per task ...

add a "static" layer, where the symbol table, gc, and mainloops+locks live
allow multiple vm's per loop, and muliple loops per vm (io and gui loops...) handle when to exit...
what about close() and stat(); they might still block or eintr ... do them on yet another thread?

bug: tlCallableIs does not know complex user objects, just try and catch not callable?

do private using $: { public: 42, $private: -1 } accessed just by $private ...
use * for vars; like this: x = var 0; *x += 1 ... add .increment/decrement and such to var

instead of hotel, lets call it arrows? .rr? .arrow? sounds nice

start preparing a first release:
* stamp every file with license/author
* use gcov to remove any unused code or add tests for them (larger parts...)

think about special inherited task local *Env*:
* for stdin/stdout/stderr
* for cwd
* for module resolving path
* for error mode (report on stdout or throw on waiter/value)

module lookup: should be in a task, should try sender path, then all module paths
but module lookup should not be automatic but maybe sys.io.chdir

add send as code primitive: target, msg, args, instead of _object_send
add op as code primitive: op, lhs, rhs

add methods vs functions, methods try to bind a this dynamically ... helps with actors too
example: function = ( -> ); method = ( @, -> )

implement `Point = { recurse: Point }` for as far as we can? do Point lazily?

add default arguments using print = (sep=" ", end="\n")->{...} etc ...
implement collector: x, *rest = multiple_return()
implement splay: return(a1, a2, *list) by return.call(a1 :: a2 :: list)
implement lvalue assignment: mutable.field = fn()

implement defer (add defer[] to tlCodeRun) or something ...

optimize: remove tlHead in favor of just a tlClass ... use last 3 bits as flags
optimize: tlFrame can use 3 bits from resumecb too ...

# missing

operators (well, the real ones)
classes (well, syntax for them and super and such ...)
class loaders for overriding/extending known classes
lazy evaluation (call by need)
finalizers
default arguments
splays on either side
complex lhs assigns

