# TODO

start using tagged doubles?
add key iterator to lhashmap, and rework tlHashMap with real kind.hash function
for tlMap and tlSet, require tlSym as keys ... clean up lots of "complexity" there

rename tlLock to tlLockValue and put in union with tlValue
add kind->resume for tlFrame
add kind->finalize for finalizers

hook up tlArgumentError to TL_ERROR
do class._name for error.toText: this.class._name ": " this.msg ...
on error, if object, call toText on it ...
add ls[item] syntax to leg parser

BUG: http server cannot be stopped, because tlReader is locked and .close will wait until accept ...

rename List -> Array, and Text -> String; Map -> Table why? because that gives users those very useful names back

add objects using:
  Square = Object { width, height ->
    methods {
      area: -> this.width * this.height
    }
  }

remove "foo $(...)" interpolation, do "foo" ... instead ...

upgrade httpparser module, add httpresponse
add /trigger to autobuilder ... wouldn't that be nice!

classes + objects should not close environments so quickly ... how to handle all this
see parser example, it cannot be factored into class + object, because class must construct itself

create a tlTTY for stdin/stdout/stderr, handle nonblock and atomic /dev/null open
* if 0,1,2 are not tty, set to nonblock
* if multiple threads; don't care, just block
* otherwise, set to nonblock just before read, and back just after read

simplify usage of libgc/libatomic_ops, it takes way to long to configure/compile?
implement a_var based on libatomic_ops ...

fix foo?bar to only catch local undefined

what about tasks.stop, ... should be workable
what about "deamon tasks" ... how can that work? maybe those don't go into io waiting?

implement print in user code, or have it call toText properly ...
do errors with nice backtraces per file etc, and per task ...

add a "static" layer, where the symbol table, gc, and mainloops+locks live
allow multiple vm's per loop, and muliple loops per vm (io and gui loops...) handle when to exit...
what about close() and stat(); they might still block or eintr ... do them on yet another thread?

bug: tlCallableIs does not know complex user objects, just try and catch not callable?
bug: { x: 42, x: runtime } is error due to duplicate x

add {{ foo }} as sugar for { foo: foo } so modules just do {{ publicFn1, publicFn2, ... }}
do private using $: { public: 42, $private: -1 } accessed just by $private ...
use * for vars; like this: x = var 0; *x += 1 ... add .increment/decrement and such to var
syntax change: do symbols using 'symbol

fix return from blocks, how about -> for block => for function wich allows return?
Or/and break with value ... ?

add @method arg, arg
instead of hotel, lets call it arrows? .rr? .arrow? sounds nice

start preparing a first release:
* stamp every file with license/author
* use gcov to remove any unused code or add tests for them (larger parts...)
* clean up and comment eval.c maybe remove some of it to run.c oid

think about special inherited task local *Env*:
* for stdin/stdout/stderr
* for cwd
* for module resolving path
* for error mode (report on stdout or throw on waiter/value)

module lookup: should be in a task, should try sender path, then all module paths
but module lookup should not be automatic but maybe sys.io.chdir

add send as code primitive: target, msg, args, instead of _object_send
add op as code primitive: op, lhs, rhs

add methods vs functions, methods try to bind a this dynamically ... helps with actors too
example: function = ( -> ); method = ( @, -> )

implement `Point = { recurse: Point }` for as far as we can? do Point lazily?
add task.stop to kill it by error? java ThreadDeath how do we do it safely?
add finalizers to tasks: report errors if nobody else reads them
add finalizers to opened files: closed the fds

add default arguments using print = (sep=" ", end="\n")->{...} etc ...
implement collector: x, *rest = multiple_return()
implement splay: return(a1, a2, *list) by return.call(a1 :: a2 :: list)
implement lvalue assignment: mutable.field = fn()

implement defer (add defer[] to tlCodeRun) or something ...

implement serializing tlValue's to disk

optimize: compiler should add all local names to code->envnames and env should use this ...
optimize: compiler can shortcut writing/referencing local names to just indexes into locals.
optimize: remove tlHead in favor of just a tlClass ... use last 3 bits as flags
optimize: tlFrame can use 3 bits from resumecb too ...
optimize: tlArgs (and tlCall) can be reworked more lean and simpler

# missing

operators (well, the real ones)
classes (well, syntax for them and super and such ...)
class loaders for overriding/extending known classes
modules
c-based modules
lazy evaluation (call by need)
finalizers
default arguments
splays on either side
complex lhs assigns
syntax for branches:
  | false -> ...
  | true -> ...

# not so nice:

args.block(42) will not execute block ... it will ignore the fact block is callable
args.block.call(42) will ignore param; why actually?
@ is not a word ... for method(42, this=something)
block: (arg ->
    return // returns way too much, should return block ... do => for functions, -> for block?
)

