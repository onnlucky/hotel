# TODO

add more unit tests and a testrunner for them

make sure symbols work all the way, bytecode statics must be symbols, args["test"] or Object.get(o, "test") must ensure a symbol, bail if symbol does not exist
add tlClass with mixins and super and fields and methods, all primitives should have a tlClass

optimize code->argspec
optimize code->hasLazy
perhaps add args->names.last as object that maps symbol to args->names index
allow tlEnv to link to a previous env, where this one can be larger, but if a value == 0, we link back, for repl and var's
allow tlEnv to have imports, so that before mod->links[global] we look up global against all scoped imports first


add something for 'collection["key", otherwise]' but will be part of get interface then
think about shared locks, so whole slew of items share single lock, especially helpful for Mutable objects
think about {call:42} meaning something different from {foo:42} and perhaps remove that "meaning" by only making call special if "object" with a "class"
implement a true class based object, vs value objects, vs maps

undefined collect stack traces, while it doesn't work as advertised ... either enhance or dumb down
tool gcov and assure make test has full coverage
work on documentation
add optional types turning into asserts, experiment with compiler discovering types
null > 1: throw undefined? or return undefined?
graphics: turn into module, by registering a vm exit function and moving vm to alternative thread
graphics: don't do the thread/blocking/reentrance dance, instead, have a single task driving native API

streams: implement some form of hold/release like cork/uncork buffer/flush

move to bytecode, remove eval based stuff
- clean up pointer flags
- remove tlSYM in favor of interned Strings, with optional pointer flag
- implement proper operators
- always allocate a frame so that exceptions and such can always find a frame, clean up all resumes

bytecode
- in bytecode, we don't need argnames, we can calculate and store that map when we need it, als we can size the args list dynamically, saves space ...
- implement classes in parser, compiler
- ensure debugger works
- have a coverage tool
- do simple optimizations in compiler, like (x + 1) * 2 does not require a body for x + 1

guarded expressions: think about a better syntax?

add "if"/"unless" to parser to do
- return if true
- return unless true
- if(true,something,otherwise)
do we want a true else? or just use guarded expressions?

add xml like things to language

add a WeakMap, add a HashMap based on regular locked hashmap implementation

add kind->resume for tlFrame and throw using frame.kind.name
add kind->finalize for finalizers and do the automatically

do class._name for error.toString: this.class._name ": " this.msg ...
on error, if object, call toString on it ...

simplify usage of libgc/libatomic_ops, it takes way to long to configure/compile?
implement a_var based on libatomic_ops ...

what about "deamon tasks" ... how can that work? maybe those don't go into io waiting?

implement print in user code, or have it call toString properly ...
do errors with nice backtraces per file etc, and per task ...

add a "static" layer, where the symbol table, gc, and mainloops+locks live
allow multiple vm's per loop, and muliple loops per vm (io and gui loops...) handle when to exit...
what about close() and stat(); they might still block or eintr ... do them on yet another thread?

bug: tlCallableIs does not know complex user objects, just try and catch not callable?

do private using $: { public: 42, $private: -1 } accessed just by $private ...
use * for vars; like this: x = var 0; *x += 1 ... add .increment/decrement and such to var

instead of hotel, lets call it arrows? .rr? .arrow? sounds nice

start preparing a first release:
* stamp every file with license/author
* use gcov to remove any unused code or add tests for them (larger parts...)

think about special inherited task local *Env*:
* for stdin/stdout/stderr
* for cwd
* for module resolving path
* for error mode (report on stdout or throw on waiter/value)

module lookup: should be in a task, should try sender path, then all module paths
but module lookup should not be automatic but maybe sys.io.chdir

add send as code primitive: target, msg, args, instead of _object_send
add op as code primitive: op, lhs, rhs

add methods vs functions, methods try to bind a this dynamically ... helps with actors too
example: function = ( -> ); method = ( @, -> )

implement `Point = { recurse: Point }` for as far as we can? do Point lazily?
add task.stop to kill it by error? java ThreadDeath how do we do it safely?
add finalizers to tasks: report errors if nobody else reads them
add finalizers to opened files: closed the fds

add default arguments using print = (sep=" ", end="\n")->{...} etc ...
implement collector: x, *rest = multiple_return()
implement splay: return(a1, a2, *list) by return.call(a1 :: a2 :: list)
implement lvalue assignment: mutable.field = fn()

implement defer (add defer[] to tlCodeRun) or something ...

implement serializing tlValue's to disk

optimize: compiler should add all local names to code->envnames and env should use this ...
optimize: compiler can shortcut writing/referencing local names to just indexes into locals.
optimize: remove tlHead in favor of just a tlClass ... use last 3 bits as flags
optimize: tlFrame can use 3 bits from resumecb too ...
optimize: tlArgs (and tlCall) can be reworked more lean and simpler

# missing

operators (well, the real ones)
classes (well, syntax for them and super and such ...)
class loaders for overriding/extending known classes
modules
c-based modules
lazy evaluation (call by need)
finalizers
default arguments
splays on either side
complex lhs assigns

# not so nice:

@ is not a word ... for method(42, this=something)

