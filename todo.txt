# TODO

remove last symbol holdouts
add closure.invoke or such where all params are given as maps and lists, to use
add Queue + max depth size or unlimited; MsgQueue and TaskQueue

add "if" to parser and do

return if true
return unless true
if true: return
unless true: return

but nothing more complex then that, we have guarded expressions for those

----

have interpreter run for N ticks per task, where N is 'somewhat' random instead of alway till the end ...

----

# <test>hello world!</test>
test("hello world!")

# <foo><a1>test</a1><a2 value=true>${1 + 1}</a2></foo>
foo(a1("test"),a2(value=true,1 + 1))

or somehow more namespaced? and maybe more flat, this will cost in lazyness ...

----

rename tlMap as tlValue and remove tlValueObject ...
for tlMap and tlSet, require tlSym as keys ... clean up lots of "complexity" there
add kind->resume for tlFrame and throw using frame.kind.name
add kind->finalize for finalizers
add tlNumber as unlimited precision decimal, and have a numeric tower from small int to decimal and floats

do class._name for error.toString: this.class._name ": " this.msg ...
on error, if object, call toString on it ...

rename List -> Array, Map -> Table why? because that gives users those very useful names back

add objects using:
  Square = Object { width, height ->
    methods {
      area: -> this.width * this.height
    }
  }

remove "foo $(...)" interpolation, do "foo" ... instead ...

upgrade httpparser module, add httpresponse

simplify usage of libgc/libatomic_ops, it takes way to long to configure/compile?
implement a_var based on libatomic_ops ...

what about "deamon tasks" ... how can that work? maybe those don't go into io waiting?

implement print in user code, or have it call toString properly ...
do errors with nice backtraces per file etc, and per task ...

add a "static" layer, where the symbol table, gc, and mainloops+locks live
allow multiple vm's per loop, and muliple loops per vm (io and gui loops...) handle when to exit...
what about close() and stat(); they might still block or eintr ... do them on yet another thread?

bug: tlCallableIs does not know complex user objects, just try and catch not callable?

add {{ foo }} as sugar for { foo: foo } so modules just do {{ publicFn1, publicFn2, ... }}
do private using $: { public: 42, $private: -1 } accessed just by $private ...
use * for vars; like this: x = var 0; *x += 1 ... add .increment/decrement and such to var
syntax change: do symbols using 'symbol

fix return from blocks, how about -> for block => for function wich allows return?
Or/and break with value ... ?

add @method arg, arg
instead of hotel, lets call it arrows? .rr? .arrow? sounds nice

start preparing a first release:
* stamp every file with license/author
* use gcov to remove any unused code or add tests for them (larger parts...)
* clean up and comment eval.c maybe remove some of it to run.c oid

think about special inherited task local *Env*:
* for stdin/stdout/stderr
* for cwd
* for module resolving path
* for error mode (report on stdout or throw on waiter/value)

module lookup: should be in a task, should try sender path, then all module paths
but module lookup should not be automatic but maybe sys.io.chdir

add send as code primitive: target, msg, args, instead of _object_send
add op as code primitive: op, lhs, rhs

add methods vs functions, methods try to bind a this dynamically ... helps with actors too
example: function = ( -> ); method = ( @, -> )

implement `Point = { recurse: Point }` for as far as we can? do Point lazily?
add task.stop to kill it by error? java ThreadDeath how do we do it safely?
add finalizers to tasks: report errors if nobody else reads them
add finalizers to opened files: closed the fds

add default arguments using print = (sep=" ", end="\n")->{...} etc ...
implement collector: x, *rest = multiple_return()
implement splay: return(a1, a2, *list) by return.call(a1 :: a2 :: list)
implement lvalue assignment: mutable.field = fn()

implement defer (add defer[] to tlCodeRun) or something ...

implement serializing tlValue's to disk

optimize: compiler should add all local names to code->envnames and env should use this ...
optimize: compiler can shortcut writing/referencing local names to just indexes into locals.
optimize: remove tlHead in favor of just a tlClass ... use last 3 bits as flags
optimize: tlFrame can use 3 bits from resumecb too ...
optimize: tlArgs (and tlCall) can be reworked more lean and simpler

# missing

operators (well, the real ones)
classes (well, syntax for them and super and such ...)
class loaders for overriding/extending known classes
modules
c-based modules
lazy evaluation (call by need)
finalizers
default arguments
splays on either side
complex lhs assigns
syntax for branches:
  | false -> ...
  | true -> ...

# not so nice:

@ is not a word ... for method(42, this=something)

