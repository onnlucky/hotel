parserParser = parser {

       sp: " " | "\t"
       nl: "\r\n" | "\n\r" | "\n" | "\r"
slcomment: "//" (!nl _)*
 icomment: "/*" (!"*/" _)* ("*/"|end)
  comment: (slcomment (nl|end) | icomment)
       ws: (sp | nl | comment)*

    name: ls=alpha+   -> ls.toChar
  escape: "\\\""      -> "\""
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"\"" l=_   -> l.toChar
    text: "\"" ts=escape* @"a closing '\"'" "\"" -> ts.join

  cscape: "\\]"       -> "]"
        | "\\n"       -> "\n"
        | "\\r"       -> "\r"
        | "\\t"       -> "\t"
        | "\\$"       -> "\$"
        | "\\\\"      -> "\\"
        | !"]" l=_    -> l.toChar
    char: "[" ts=cscape* @"closing ']'" "]"      -> ts.join

     act: "->". ts=(!"\n" _)*             -> ts.toChar
    cond: "?"."(". ts=(!")" _)* ")"       -> ts.toChar

    term: "(". t=or @"a closing ')'" .")" -> { type: #Sub, term: t }
        | "."                             -> { type: #Ws }
        | "_"                             -> { type: #Any }
        | c=cond                          -> { type: #Cond, act: c }
        | n=name !":"                     -> { type: #Call, rule: n }
        | t=text                          -> { type: #Text, text: t }
        | t=char                          -> { type: #Char, text: t }
    post: "!" @"a term" t=term            -> { type: #Not, term: t }
        | "&" @"a term" t=term            -> { type: #Ahead, term: t }
        | t=term "*"                      -> { type: #Star, term: t }
        | t=term "+"                      -> { type: #Plus, term: t }
        | t=term "?"                      -> { type: #Opt, term: t }
        | term
   named: n=name "=" @"a term"  t=post    -> { type: #Bind, name: n, term: t }
        | "@" t=text                      -> { type: #NoReturn, msg: t }
        | post
     and: h=named rs=(.named)* .a=act?    -> { type: #And, terms: [h].cat(rs), act: a }
      or: @"some terms"
          h=and rs=(."|". and)*           -> { type: #Or, terms: [h].cat(rs) }
    rule: .n=name @":" .":". t=or         -> { type: #Rule, name: n, term: t }
  parser: n=name ."="."parser"."{"
          rs=rule*
          @"a closing '}'" ."}"           -> { n: n, rs: rs }
   start: b=(!(name ."="."parser"."{") _)*
          p=parser
          a=_*                            -> { before: b.toChar, after: a.toChar, rules: p.rs, name: p.n }
}

// emitting
emit = { r, buf, ind, name ->
    _match(r.type == #Or): goto emitOr r, buf, ind
    _match(r.type == #And): goto emitAnd r, buf, ind
    _match(r.type == #Sub): goto emitSub r, buf, ind
    _match(r.type == #Not): goto emitNot r, buf, ind
    _match(r.type == #Opt): goto emitOpt r, buf, ind
    _match(r.type == #Star): goto emitStar r, buf, ind
    _match(r.type == #Plus): goto emitPlus r, buf, ind

    _match(r.type == #Ahead): goto emitAhead r, buf, ind
    _match(r.type == #Cond): buf.write("$ind  if not ($(r.act)): error(_in, _nr, \"if not ($(r.act.escape))\")\n")
    _match(r.type == #Char): buf.write("$ind  _in, _v = pChar(_in, _nr, \"$(r.text.escape)\")\n")

    _match(r.type == #NoReturn): buf.write("$ind  _nr = \"$(r.msg.escape)\"\n")
    _match(r.type == #Call): buf.write("$ind  _in, _v = rule_$(r.rule)(_in, _nr)\n")
    _match(r.type == #Bind): emit(r.term, buf, ind); buf.write("$(ind)  $(r.name) = _v; pAct(_in, _v)\n")
    _match(r.type == #Text): buf.write("$ind  _in, _v = pText(_in, _nr, \"$(r.text.escape)\")\n")
    _match(r.type == #Ws): buf.write("$ind  _in, _v = rule_ws(_in, _nr)\n")
    _match(r.type == #Any): buf.write("$ind  _in, _v = rule_any(_in, _nr)\n")
    _match(true): _throw "InternalError emit unknown: $(r.type)"
    _nomatch
}
emitAhead = { r, buf, ind ->
    buf.write("$ind  _in, _v = pAhead(_in, _nr, {_in, _nr ->\n")
    emit r.term, buf, ind.cat("  ")
    buf.write("$ind  })\n")
}
emitNot = { r, buf, ind ->
    buf.write("$ind  _in, _v = pNot(_in, _nr, {_in, _nr ->\n")
    emit r.term, buf, ind.cat("  ")
    buf.write("$ind  })\n")
}
emitOpt = { r, buf, ind ->
    buf.write("$ind  _in, _v = pOpt(_in, _nr, {_in, _nr ->\n")
    emit r.term, buf, ind.cat("  ")
    buf.write("$ind  })\n")
}
emitStar = { r, buf, ind ->
    buf.write("$ind  _in, _v = pStar(_in, _nr, {_in, _nr ->\n")
    emit r.term, buf, ind.cat("  ")
    buf.write("$ind  })\n")
}
emitPlus = { r, buf, ind ->
    buf.write("$ind  _in, _v = pPlus(_in, _nr, {_in, _nr ->\n")
    emit r.term, buf, ind.cat("  ")
    buf.write("$ind  })\n")
}
emitAnd = { r, buf, ind ->
    var $n = 0
    // TODO maybe collect all binds, and "call" r.act
    r.terms.each: r -> emit r, buf, ind
    if r.act: buf.write("$ind  _in, _v = pAct(_in, ($(r.act)))\n")
}
emitOr = { r, buf, ind ->
    if r.terms.size == 0: return
    if r.terms.size == 1: return emit(r.terms.get(0), buf, ind)

    buf.write("$ind  _in, _v = pOr(_in, _nr, _name\n")
    r.terms.each: { r =>
        buf.write("$ind    ,{_in, _nr ->\n")
        emit r, buf, ind.cat("    ")
        buf.write("$ind     }\n")
    }
    buf.write("$ind  )\n")
}
emitSub = { r, buf, ind ->
    buf.write("$ind  _in, _v = {_in, _nr ->\n")
    emit r.term, buf, ind.cat("  ")
    buf.write("$ind  }(_in, _nr)\n")
}
emitRule = { r, buf ->
    name = r.name
    buf.write("rule_$name = {_in, _nr ->\n")
    buf.write("  _catch: e -> pHandle(e, _nr, \"$name\")\n")
    buf.write("  trace(_in, \" >>  TRY $name\", _nr)\n")
    buf.write("  _name = \"$name\"\n")
    emit r.term, buf, ""
    buf.write("  trace(_in, \" << !OK! $name\")\n")
    buf.write("  return _in, _v\n")
    buf.write("}\n")
}

if not args.get(1): _throw "Usage: <input.tl> <output.tl>"

ast = parserParser(io.File(args.get(0)).read)

buf = io.Buffer.new
buf.write(ast.before)
buf.write("\n// --- tlmeta-base.tl ---\n")
buf.write(io.File("tlmeta-base.tl").read)
buf.write("\n// --- parser ---\n")
var $hasstart = false
ast.rules.each: { r ->
    if r.name == "start": $hasstart = true
    emitRule r, buf
}
start = (if $hasstart: "start") or ast.rules.get(0).name
buf.write("$(ast.name)$("") = text -> pStart(rule_$start, text)\n")
buf.write("\n// ---\n")
buf.write(ast.after)

io.File(args.get(1)).write(buf)
print "written '$(args.get(1))'"

